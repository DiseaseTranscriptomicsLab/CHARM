---
title: "CHARM: Data Processing"
subtitle: "Comprehensive Hub for Alternative Regulatory Mapping"
author: 
  - name: "Alexandre Kaizeler^[Disease Transcriptomics Group, Gulbenkian Institute of Molecular Medicine]"
    email: alexandreafonso@gimm.pt
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  rmdformats::downcute:
    downcute_theme: "chaos"
---

# General

## Import libraries

```{r libraries, echo=FALSE}
# These are all the libraries I used throughout the analysis. Not all of them will be required on this guidebook
library(Rsubread)
library(limma)
library(edgeR)
library(DESeq2)
library(magrittr)
library(ggrepel)
library(tidyverse)
library(vsn)
library(ggplot2)
library(NMF)
library(biomaRt)
library(ggpubr)
library(factoextra)
library(ggfortify)
library(plotly)
library(reshape2)
library(fgsea)
library(msigdbr)
library(data.table)
library(colorspace)
library(readxl)
library(fs)

set.seed(1906)
```

# A. Data Processing 

*Date: August 19th 2025*

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup

### Import data

To create the R object that we will use for CHARM, we need three data types:

Expression: Differential expression upon RBP knockdown/knockout, with pathway-level insights from Gene Set Enrichment Analysis.

Splicing: Alternative splicing changes quantified with betAS (Ferreira et al., 2024), using VastDB nomenclature (Tapial et al., 2017).

Binding: Altered RNA binding patterns of the silenced RBP and other RBPs, characterized with the eCLIPSE tool.

#### Expression

Preparation of the read count table, of K562 and HEPG2 cells exposed to knockdown/knockout of RBP and their respective control. All of these samples were obtained from the ENCODE project (Luo et al., 2020), and processed through the vast-tools pipeline (Tapial et al., 2017). As such, the raw fastq samples obtained from ENCODE were aligned with Bowtie.

```{r}
#All of these different raw counts were obtained on an RBP by RBP basis. They are separated by folders. First I will create a list with all of this information.
#By nature, Bowtie also gives us FPKM. I will focus on Counts, and so will remove all unnecessary information. For rows with the same gene names, I simply merge the counts together.
#You will notice the function has some failsafe parts to note errors where there was some human error on my part. 
#In theory, this should be fine now.

build_rawcounts_list <- function(
  base_path = "~/Projects/StressGranules/AS.WC_Transcriptome/shRNAExp"
) {
  base_path <- fs::path_expand(base_path)

  subdirs <- fs::dir_ls(base_path, type = "directory", recurse = FALSE)
  folder_names <- fs::path_file(subdirs)

  out <- setNames(
    lapply(folder_names, function(folder) {
      vast_dir <- fs::path(base_path, folder, "TrimmedSamples", "vast_out")
      if (!fs::dir_exists(vast_dir)) {
        message("Missing directory: ", vast_dir)
        return(list(rawcounts = NULL))
      }

      matches <- fs::dir_ls(vast_dir, type = "file", regexp = "cRPKM_AND_COUNTS")
      if (length(matches) == 0) {
        message("No 'cRPKM_AND_COUNTS' file in: ", vast_dir)
        return(list(rawcounts = NULL))
      }
      if (length(matches) > 1) {
        info <- fs::file_info(matches)
        matches <- matches[order(info$modification_time, decreasing = TRUE)]
        message("Multiple matches in ", vast_dir, "; using latest: ", fs::path_file(matches[1]))
      }

      dt <- data.table::fread(matches[1])

      # --- 1) Drop columns named exactly "ID" or containing "RPKM"
      cols_to_drop <- grep("^ID$|RPKM", names(dt), value = TRUE)
      if (length(cols_to_drop) > 0) {
        dt[, (cols_to_drop) := NULL]
      }

      # --- 2) Normalise "Name" column casing and aggregate duplicates (NA -> 0)
      name_idx <- which(tolower(names(dt)) == "name")
      if (length(name_idx) == 1L) {
        setnames(dt, name_idx, "Name")
      }
      if ("Name" %in% names(dt)) {
        num_cols <- names(dt)[vapply(dt, is.numeric, logical(1))]
        dt <- dt[, lapply(.SD, function(x) sum(x, na.rm = TRUE)), by = Name, .SDcols = num_cols]
      }

      # --- 3) Flag columns that CONTAIN a digits_digits substring anywhere (e.g. "1_1")
      suspicious_cols <- grep("\\d+_\\d+", names(dt), value = TRUE)
      if (length(suspicious_cols) > 0) {
        message("⚠️ Folder ", folder, " has columns with integer_integer substrings: ",
                paste(suspicious_cols, collapse = ", "))
      }

      list(rawcounts = dt)
    }),
    folder_names
  )

  out
}

# Run
#This creates the CharmObj
CharmObj_rbp <- build_rawcounts_list()

```

#### Metadata

```{r}
add_metadata <- function(obj) {
  lapply(names(obj), function(folder) {
    rc <- obj[[folder]]$rawcounts
    
    if (is.null(rc)) {
      return(list(rawcounts = NULL, SampleType = NULL, Cell = NULL, Experiment = NULL))
    }
    
    cols <- names(rc)[-1]  # drop first column (Name)
    
    # SampleType
    sample_type <- vapply(cols, function(col) {
      if (grepl("control", col, ignore.case = TRUE)) {
        "Control"
      } else if (grepl("shrna", col, ignore.case = TRUE)) {
        folder
      } else {
        NA_character_
      }
    }, character(1))
    
    # Cell type
    cell <- vapply(cols, function(col) {
      if (grepl("K562", col, ignore.case = TRUE)) {
        "K562"
      } else if (grepl("HEPG2", col, ignore.case = TRUE)) {
        "HEPG2"
      } else {
        NA_character_
      }
    }, character(1))
    
    # Experiment: just the folder name repeated for all columns
    experiment <- rep(folder, length(cols))
    
    list(
      rawcounts  = rc,
      SampleType = sample_type,
      Cell       = cell,
      Experiment = experiment
    )
  }) |> setNames(names(obj))
}

# ---- Apply to your CharmObj ----
CharmObj_rbp <- add_metadata(CharmObj_rbp)

```

#### Create CHARM Object

```{r}
collapse_charmobj <- function(obj) {
  expr_list       <- list()
  sampletype_list <- list()
  cell_list       <- list()
  experiment_list <- list()  # NEW

  for (folder in names(obj)) {
    rc <- obj[[folder]]$rawcounts
    if (is.null(rc)) next

    # normalize 'Name' column casing
    name_idx <- which(tolower(names(rc)) == "name")
    if (length(name_idx) == 1L) setnames(rc, name_idx, "Name")

    # new column names: just add _folder for uniqueness
    orig_cols <- names(rc)[-1]
    new_cols  <- paste0(orig_cols, "_", folder)
    setnames(rc, c("Name", new_cols))

    expr_list[[folder]]       <- rc
    sampletype_list[[folder]] <- obj[[folder]]$SampleType
    cell_list[[folder]]       <- obj[[folder]]$Cell
    experiment_list[[folder]] <- obj[[folder]]$Experiment  # NEW
  }

  if (!length(expr_list)) {
    return(list(rawcounts = NULL, SampleType = NULL, Cell = NULL, Experiment = NULL))
  }

  # merge expression tables by Name
  rawcounts <- Reduce(
    function(x, y) merge(x, y, by = "Name", all = TRUE, sort = FALSE),
    expr_list
  )
  setDT(rawcounts)

  # concatenate metadata across all folders
  SampleType <- unlist(sampletype_list, use.names = FALSE)
  Cell       <- unlist(cell_list,       use.names = FALSE)
  Experiment <- unlist(experiment_list, use.names = FALSE)  # NEW

  stopifnot(length(SampleType) == ncol(rawcounts) - 1L,
            length(Cell)       == ncol(rawcounts) - 1L,
            length(Experiment) == ncol(rawcounts) - 1L)  # NEW

  list(
    rawcounts  = rawcounts,
    SampleType = SampleType,
    Cell       = Cell,
    Experiment = Experiment  # NEW
  )
}

# ---- Run it ----
Charm.object <- collapse_charmobj(CharmObj_rbp)

Charm.object$rawcounts <- as.data.frame(Charm.object$rawcounts)
row.names(Charm.object$rawcounts) <- Charm.object$rawcounts$Name
Charm.object$rawcounts$Name <- NULL

```


#### Filtration (Density Plot)

In this version, every RBP is processed sepparetely, as if they were their own expression/tissue.

```{r}
alternew <- log10(rowSums(Charm.object$rawcounts))
alternew <- as.data.frame(alternew)

ggplot(alternew, aes(x=alternew)) + geom_density() + theme_bw() + geom_vline(xintercept = 5, linetype = "dashed") + ylab("Events") + xlab("Number of Reads (log10)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + ggtitle("Density of Reads - All Samples")

filterednew <- subset(Charm.object$rawcounts, alternew>5)


#after cutting, its a good idea to visualize again
falternew <- log10(rowSums(filterednew))
falternew <- as.data.frame(falternew)
ggplot(falternew, aes(x=falternew)) + geom_density() + theme_bw() + ylab("Events") + xlab("Number of Reads (log10)") +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

#lets save the genes which we maintain
impgenes <- c(row.names(falternew))


#Now we need to select only the rows which have those genes.
Charm.object$filtcounts <- Charm.object$rawcounts[row.names(Charm.object$rawcounts)%in%impgenes,]
```



#### Matrix Design

Good! Now we can proceed by designing our matrices. 

```{r}
#To be able to use Voom, we must first convert our read count table into a special DGE object.
D0 <- DGEList(Charm.object$filtcounts)


#Then we calculate the normalisation factors for these new generated data frames
#Bear in mind this step calculates the normalisation factors, but does not normalise itself.
D0 <- calcNormFactors(D0)

metadata <- data.frame(Sample=Charm.object$SampleType, Cell=Charm.object$Cell, Experiment=Charm.object$Experiment)


#Now we do the matrixes
mm <- model.matrix(~0+Sample+Cell+Experiment, metadata)


#and now we normalise. This step also turns our counts into log2-counts per million.
y <- voom(D0, mm, plot = T)
Charm.object$normcounts <- as.data.frame(y$E)
```

#### Normalisation

Now, we are almost ready to move on to the differential gene expression analysis. I will first check to see if any issues arose during the normalisation process, by looking at samples before and after this process.

```{r}

# Function to filter top 10 and bottom 10 samples
select_extreme_samples <- function(counts_matrix) {
  # Compute total reads per sample
  sample_sums <- colSums(counts_matrix)

  # Select 10 highest and 10 lowest
  selected_samples <- c(
    names(sort(sample_sums, decreasing = TRUE)[1:10]),
    names(sort(sample_sums, decreasing = FALSE)[1:10])
  )

  # Subset counts matrix
  counts_matrix[, selected_samples, drop = FALSE]
}

# ----------------------------
# Prior to Normalisation
# ----------------------------
dfforboxy <- Charm.object$filtcounts
dfforboxy <- select_extreme_samples(dfforboxy)

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")

prenorm <- ggplot(dfforboxy, aes(x = Sample, y = log2(Expression + 1))) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle("Prior to Normalisation")

# ----------------------------
# After Normalisation
# ----------------------------
dfforboxy <- Charm.object$normcounts
dfforboxy <- select_extreme_samples(dfforboxy)

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")


postnorm <- ggplot(dfforboxy, aes(x = Sample, y = Expression)) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2CPM)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle("After Normalisation")

ggarrange(prenorm, postnorm, nrow = 1)
```

Normalisation isn't ideal, but it isn't too bad either.

#### Batch Correction

As an extra layer, we can also consider "cell type" as a batch factor. Here is the process I used to do so. For more information, please consult Schneider et al (voyAGEr).

```{r}
batch_cols <- c("Cell","Experiment")
metadata_cols <- c("Sample")
mmbatch <- model.matrix(reformulate(paste0("~0 + ",paste0( batch_cols,collapse = " + "))), data=metadata)
mmkeep <- model.matrix(reformulate(paste0("~0 + ",paste0( metadata_cols,collapse =  "+" ))), data=metadata)
mm <- cbind(mmkeep,mmbatch)
D0 <- DGEList(2^y$E) 
D0 <- calcNormFactors(D0)
y <- voom(D0, mm, plot = F)
fit <- lmFit(y, mm)
beta <- fit$coefficients[,-(1:ncol(mmkeep)),drop=FALSE]
beta[is.na(beta)] <- 0
corrcounts_v1 <- as.matrix(y$E) - beta %*% t(mmbatch)
offset <- apply(corrcounts_v1,1,min) - apply(y$E,1,min)
corrcounts_v1 <- as.data.frame(corrcounts_v1-offset)
corrcounts_v1 <- 2^corrcounts_v1

mm <- model.matrix(~0+Sample, metadata)

y <- voom(corrcounts_v1, mm, plot = T)
Charm.object$corcounts <- as.data.frame(y$E)

saveRDS(Charm.object, "../Data_Objects/Charm.object.RDS")
```

#### Data Exploration (PCA) Part 1

I will be using PCA to find out what most influences the expression.

##### PCA without Batch Correction, All Samples

```{r fig.height=4, fig.width=12}
#This prepares my data for the PCA
dfforpca <- Charm.object$normcounts
dfforpca <- t(dfforpca)
dfforpca <- as.data.frame(dfforpca) # needs to be a data.frame
dfforpca <- apply(dfforpca, 2, as.numeric) # Ensure numeric
dfforpca <- as.data.frame(dfforpca) # still needs to be a data.frame

# Add metadata, which we will then use to plot
dfforpca$Sample <- Charm.object$SampleType
dfforpca$Cell <- Charm.object$Cell

dfforpca$Sample <- ifelse(dfforpca$Sample == "Control", "Control", "Other")

# PCA computation itself. I do one PCA for each variable I want to see.
pca_res <- prcomp(dfforpca[, 1:(ncol(dfforpca)-2)], scale = FALSE)
p_sample<- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Sample",  size = 4, alpha=0.6) +
  theme_bw() +
  scale_colour_manual(name = "Sample", values = c("#7272AB", "#283D3B")) +
  ggtitle("PCA - Coloured by Sample") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.line = element_line(colour = "black"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

p_cell <- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Cell", size = 4, alpha=0.6) +
  theme_bw() +
  scale_colour_manual(name = "Cell", values = c("#80B192", "#8E4A49")) +
  ggtitle("PCA - Coloured by Cell") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.line = element_line(colour = "black"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

ggarrange(p_cell, p_sample)

#in case you want to see most important genes for PCA yourself
contribs1 <- pca_res$rotation[,1]
contribs2 <- pca_res$rotation[,2]

#These are the biggest contributors to the PCA1 (right side)
(pos1genes <- sort(contribs1, decreasing=T)[1:10])
#These are the biggest contributors to the PCA1 (left side)
(neg1genes <- sort(contribs1, decreasing=F)[1:10])

#These are the biggest contributors to the PCA2 (up side)
(pos2genes <- sort(contribs2, decreasing=T)[1:10])
#These are the biggest contributors to the PCA2 (down side)
(neg2genes <- sort(contribs2, decreasing=F)[1:10])

```


##### PCA without Batch Correction, Separated Cells

```{r fig.height=4, fig.width=12}
#---------------------------------------
# Function to run PCA and plot for a given cell type
#---------------------------------------
plot_pca_by_cell <- function(Charm.object, cell_type, control_color = "#7272AB", other_color = "#283D3B") {
  
  # Prepare the data
  dfforpca <- Charm.object$normcounts
  dfforpca <- t(dfforpca)
  dfforpca <- as.data.frame(dfforpca)
  dfforpca <- apply(dfforpca, 2, as.numeric)
  dfforpca <- as.data.frame(dfforpca)
  
  # Add metadata
  dfforpca$Sample <- Charm.object$SampleType
  dfforpca$Cell <- Charm.object$Cell
  
  # Subset to the requested cell type
  dfforpca <- dfforpca[dfforpca$Cell == cell_type, ]
  
  # Highlight Control vs Other
  dfforpca$Sample <- ifelse(dfforpca$Sample == "Control", "Control", "Other")
  
  # PCA computation
  pca_res <- prcomp(dfforpca[, 1:(ncol(dfforpca)-2)], scale = FALSE)
  
  # PCA plot
  p_sample <- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Sample", size = 4, alpha = 0.6) +
    theme_bw() +
    scale_colour_manual(name = "Sample", values = c("Control" = control_color, "Other" = other_color)) +
    ggtitle(paste("PCA - Coloured by Sample (", cell_type, ")", sep = "")) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  # Optional: check most important genes
  contribs1 <- pca_res$rotation[,1]
  contribs2 <- pca_res$rotation[,2]
  
  pos1genes <- sort(contribs1, decreasing = TRUE)[1:10]
  neg1genes <- sort(contribs1, decreasing = FALSE)[1:10]
  pos2genes <- sort(contribs2, decreasing = TRUE)[1:10]
  neg2genes <- sort(contribs2, decreasing = FALSE)[1:10]
  
  list(plot = p_sample, pos1genes = pos1genes, neg1genes = neg1genes,
       pos2genes = pos2genes, neg2genes = neg2genes)
}

#---------------------------------------
# Run for HEPG2
#---------------------------------------
hepg2_results <- plot_pca_by_cell(Charm.object, "HEPG2")


#---------------------------------------
# Run for K562
#---------------------------------------
k562_results <- plot_pca_by_cell(Charm.object, "K562")



ggarrange(hepg2_results$plot, k562_results$plot)
```


##### PCA without Batch Correction, No Controls

```{r fig.height=4, fig.width=12}
#---------------------------------------
# Function to run PCA and plot for a given cell type
#---------------------------------------
plot_pca_by_cell <- function(Charm.object, cell_type, other_color = "#283D3B") {
  
  # Prepare the data
  dfforpca <- Charm.object$normcounts
  dfforpca <- t(dfforpca)
  dfforpca <- as.data.frame(dfforpca)
  dfforpca <- apply(dfforpca, 2, as.numeric)
  dfforpca <- as.data.frame(dfforpca)
  
  # Add metadata
  dfforpca$Sample <- Charm.object$SampleType
  dfforpca$Cell   <- Charm.object$Cell
  
  # Subset to the requested cell type AND remove controls
  dfforpca <- dfforpca[dfforpca$Cell == cell_type & dfforpca$Sample != "Control", ]
  
  # Relabel everything as "Other" (since controls are gone)
  dfforpca$Sample <- "Other"
  
  # PCA computation
  pca_res <- prcomp(dfforpca[, 1:(ncol(dfforpca)-2)], scale = FALSE)
  
  # PCA plot
  p_sample <- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Sample", size = 4, alpha = 0.6) +
    theme_bw() +
    scale_colour_manual(name = "Sample", values = c("Other" = other_color)) +
    ggtitle(paste("PCA - Only shRNA samples (", cell_type, ")", sep = "")) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  # Optional: check most important genes
  contribs1 <- pca_res$rotation[,1]
  contribs2 <- pca_res$rotation[,2]
  
  pos1genes <- sort(contribs1, decreasing = TRUE)[1:10]
  neg1genes <- sort(contribs1, decreasing = FALSE)[1:10]
  pos2genes <- sort(contribs2, decreasing = TRUE)[1:10]
  neg2genes <- sort(contribs2, decreasing = FALSE)[1:10]
  
  list(plot = p_sample, pos1genes = pos1genes, neg1genes = neg1genes,
       pos2genes = pos2genes, neg2genes = neg2genes)
}

#---------------------------------------
# Run for HEPG2 (no controls)
#---------------------------------------
hepg2_results <- plot_pca_by_cell(Charm.object, "HEPG2")

#---------------------------------------
# Run for K562 (no controls)
#---------------------------------------
k562_results <- plot_pca_by_cell(Charm.object, "K562")

# Combine plots
ggarrange(hepg2_results$plot, k562_results$plot)

```

#### Data Exploration (PCA) Part 2

I will be using PCA to find out what most influences the expression.

##### PCA with Batch Correction, All Samples

```{r fig.height=4, fig.width=12}
#This prepares my data for the PCA
dfforpca <- Charm.object$corcounts
dfforpca <- t(dfforpca)
dfforpca <- as.data.frame(dfforpca) # needs to be a data.frame
dfforpca <- apply(dfforpca, 2, as.numeric) # Ensure numeric
dfforpca <- as.data.frame(dfforpca) # still needs to be a data.frame

# Add metadata, which we will then use to plot
dfforpca$Sample <- Charm.object$SampleType
dfforpca$Cell <- Charm.object$Cell

dfforpca$Sample <- ifelse(dfforpca$Sample == "Control", "Control", "Other")

# PCA computation itself. I do one PCA for each variable I want to see.
pca_res <- prcomp(dfforpca[, 1:(ncol(dfforpca)-2)], scale = FALSE)
p_sample<- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Sample",  size = 4, alpha=0.6) +
  theme_bw() +
  scale_colour_manual(name = "Sample", values = c("#7272AB", "#283D3B")) +
  ggtitle("PCA - Coloured by Sample") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.line = element_line(colour = "black"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

p_cell <- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Cell", size = 4, alpha=0.6) +
  theme_bw() +
  scale_colour_manual(name = "Cell", values = c("#80B192", "#8E4A49")) +
  ggtitle("PCA - Coloured by Cell") +
  theme(plot.title = element_text(hjust = 0.5),
        axis.line = element_line(colour = "black"),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank())

ggarrange(p_cell, p_sample)

#in case you want to see most important genes for PCA yourself
contribs1 <- pca_res$rotation[,1]
contribs2 <- pca_res$rotation[,2]

#These are the biggest contributors to the PCA1 (right side)
(pos1genes <- sort(contribs1, decreasing=T)[1:10])
#These are the biggest contributors to the PCA1 (left side)
(neg1genes <- sort(contribs1, decreasing=F)[1:10])

#These are the biggest contributors to the PCA2 (up side)
(pos2genes <- sort(contribs2, decreasing=T)[1:10])
#These are the biggest contributors to the PCA2 (down side)
(neg2genes <- sort(contribs2, decreasing=F)[1:10])

```


##### PCA with Batch Correction, Separated Cells

```{r fig.height=4, fig.width=12}
#---------------------------------------
# Function to run PCA and plot for a given cell type
#---------------------------------------
plot_pca_by_cell <- function(Charm.object, cell_type, control_color = "#7272AB", other_color = "#283D3B") {
  
  # Prepare the data
  dfforpca <- Charm.object$corcounts
  dfforpca <- t(dfforpca)
  dfforpca <- as.data.frame(dfforpca)
  dfforpca <- apply(dfforpca, 2, as.numeric)
  dfforpca <- as.data.frame(dfforpca)
  
  # Add metadata
  dfforpca$Sample <- Charm.object$SampleType
  dfforpca$Cell <- Charm.object$Cell
  
  # Subset to the requested cell type
  dfforpca <- dfforpca[dfforpca$Cell == cell_type, ]
  
  # Highlight Control vs Other
  dfforpca$Sample <- ifelse(dfforpca$Sample == "Control", "Control", "Other")
  
  # PCA computation
  pca_res <- prcomp(dfforpca[, 1:(ncol(dfforpca)-2)], scale = FALSE)
  
  # PCA plot
  p_sample <- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Sample", size = 4, alpha = 0.6) +
    theme_bw() +
    scale_colour_manual(name = "Sample", values = c("Control" = control_color, "Other" = other_color)) +
    ggtitle(paste("PCA - Coloured by Sample (", cell_type, ")", sep = "")) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  # Optional: check most important genes
  contribs1 <- pca_res$rotation[,1]
  contribs2 <- pca_res$rotation[,2]
  
  pos1genes <- sort(contribs1, decreasing = TRUE)[1:10]
  neg1genes <- sort(contribs1, decreasing = FALSE)[1:10]
  pos2genes <- sort(contribs2, decreasing = TRUE)[1:10]
  neg2genes <- sort(contribs2, decreasing = FALSE)[1:10]
  
  list(plot = p_sample, pos1genes = pos1genes, neg1genes = neg1genes,
       pos2genes = pos2genes, neg2genes = neg2genes)
}

#---------------------------------------
# Run for HEPG2
#---------------------------------------
hepg2_results <- plot_pca_by_cell(Charm.object, "HEPG2")


#---------------------------------------
# Run for K562
#---------------------------------------
k562_results <- plot_pca_by_cell(Charm.object, "K562")



ggarrange(hepg2_results$plot, k562_results$plot)
```

##### PCA with Batch Correction, No Controls, Separated

```{r fig.height=4, fig.width=12}
#---------------------------------------
# Function to run PCA and plot for a given cell type
#---------------------------------------
plot_pca_by_cell <- function(Charm.object, cell_type, other_color = "#283D3B") {
  
  # Prepare the data
  dfforpca <- Charm.object$corcounts
  dfforpca <- t(dfforpca)
  dfforpca <- as.data.frame(dfforpca)
  dfforpca <- apply(dfforpca, 2, as.numeric)
  dfforpca <- as.data.frame(dfforpca)
  
  # Add metadata
  dfforpca$Sample <- Charm.object$SampleType
  dfforpca$Cell   <- Charm.object$Cell
  
  # Subset to the requested cell type AND remove controls
  dfforpca <- dfforpca[dfforpca$Cell == cell_type & dfforpca$Sample != "Control", ]
  
  # Relabel everything as "Other" (since controls are gone)
  dfforpca$Sample <- "Other"
  
  # PCA computation
  pca_res <- prcomp(dfforpca[, 1:(ncol(dfforpca)-2)], scale = FALSE)
  
  # PCA plot
  p_sample <- autoplot(pca_res, data = dfforpca, x = 1, y = 2, colour = "Sample", size = 4, alpha = 0.6) +
    theme_bw() +
    scale_colour_manual(name = "Sample", values = c("Other" = other_color)) +
    ggtitle(paste("PCA - Only shRNA samples (", cell_type, ")", sep = "")) +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  # Optional: check most important genes
  contribs1 <- pca_res$rotation[,1]
  contribs2 <- pca_res$rotation[,2]
  
  pos1genes <- sort(contribs1, decreasing = TRUE)[1:10]
  neg1genes <- sort(contribs1, decreasing = FALSE)[1:10]
  pos2genes <- sort(contribs2, decreasing = TRUE)[1:10]
  neg2genes <- sort(contribs2, decreasing = FALSE)[1:10]
  
  list(plot = p_sample, pos1genes = pos1genes, neg1genes = neg1genes,
       pos2genes = pos2genes, neg2genes = neg2genes)
}

#---------------------------------------
# Run for HEPG2 (no controls)
#---------------------------------------
hepg2_results <- plot_pca_by_cell(Charm.object, "HEPG2")

#---------------------------------------
# Run for K562 (no controls)
#---------------------------------------
k562_results <- plot_pca_by_cell(Charm.object, "K562")

# Combine plots
ggarrange(hepg2_results$plot, k562_results$plot)

```


##### PCA with Batch Correction, No Controls


```{r fig.height=5, fig.width=6}
#---------------------------------------
# PCA for both cell types together (no controls, generic coloring)
#---------------------------------------
plot_pca_no_controls <- function(Charm.object, other_color = "#283D3B") {
  
  # Prepare the data
  dfforpca <- Charm.object$corcounts
  dfforpca <- t(dfforpca)
  dfforpca <- as.data.frame(dfforpca)
  dfforpca <- apply(dfforpca, 2, as.numeric)
  dfforpca <- as.data.frame(dfforpca)
  
  # Add metadata
  dfforpca$Sample <- Charm.object$SampleType
  dfforpca$Cell   <- Charm.object$Cell
  
  # Remove controls only
  dfforpca <- dfforpca[dfforpca$Sample != "Control", ]
  
  # Relabel everything as "Other"
  dfforpca$Sample <- "Other"
  
  # PCA computation
  pca_res <- prcomp(dfforpca[, 1:(ncol(dfforpca)-2)], scale = FALSE)
  
  # PCA plot (all same color)
  p_sample <- autoplot(pca_res, data = dfforpca, x = 1, y = 2, 
                       colour = "Sample", size = 4, alpha = 0.6) +
    theme_bw() +
    scale_colour_manual(values = c("Other" = other_color)) +
    ggtitle("PCA - Only shRNA samples (HEPG2 + K562)") +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  # Optional: check most important genes
  contribs1 <- pca_res$rotation[,1]
  contribs2 <- pca_res$rotation[,2]
  
  pos1genes <- sort(contribs1, decreasing = TRUE)[1:10]
  neg1genes <- sort(contribs1, decreasing = FALSE)[1:10]
  pos2genes <- sort(contribs2, decreasing = TRUE)[1:10]
  neg2genes <- sort(contribs2, decreasing = FALSE)[1:10]
  
  list(plot = p_sample, pos1genes = pos1genes, neg1genes = neg1genes,
       pos2genes = pos2genes, neg2genes = neg2genes)
}

#---------------------------------------
# Run PCA for both cells (no controls, generic coloring)
#---------------------------------------
all_results <- plot_pca_no_controls(Charm.object)

all_results$plot
```
##### TSNE

```{r}

library(Rtsne)

plot_tsne <- function(Charm.object, other_color = "#283D3B", seed = 42, perplexity = 30) {
  
  # Prepare the data
  dffortsne <- Charm.object$corcounts
  dffortsne <- t(dffortsne)
  dffortsne <- as.data.frame(dffortsne)
  dffortsne <- apply(dffortsne, 2, as.numeric)
  dffortsne <- as.data.frame(dffortsne)
  
  # Add metadata
  dffortsne$Sample <- Charm.object$SampleType
  dffortsne$Cell   <- Charm.object$Cell
  
  # Remove controls
  dffortsne <- dffortsne[dffortsne$Sample != "Control", ]
  
  # Relabel everything as "Other"
  dffortsne$Sample <- "Other"
  
  # Run t-SNE on expression data only
  set.seed(seed)
  tsne_res <- Rtsne(dffortsne[, 1:(ncol(dffortsne)-2)], 
                    perplexity = perplexity, 
                    verbose = TRUE, 
                    check_duplicates = FALSE)
  
  tsne_df <- data.frame(
    Dim1   = tsne_res$Y[,1],
    Dim2   = tsne_res$Y[,2],
    Sample = dffortsne$Sample,
    Cell   = dffortsne$Cell
  )
  
  # Plot
  p_tsne <- ggplot(tsne_df, aes(x = Dim1, y = Dim2, colour = Sample)) +
    geom_point(size = 4, alpha = 0.6) +
    theme_bw() +
    scale_colour_manual(name = "Sample", values = c("Other" = other_color)) +
    ggtitle("t-SNE - Only shRNA samples (HEPG2 + K562)") +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank()
    )
  
  return(p_tsne)
}

# Run it
tsne_plot <- plot_tsne(Charm.object)
tsne_plot
```


##### Knockdown/knockout Integrity

I first check if indeed there is a knockdown of treated RBP.

```{r}

shRNA_integrity <- function(Charmobj, rbp, varoi){
  # Expression matrix
  expr <- Charmobj$corcounts
  
  # Build design matrix
  group <- Charmobj[[varoi]]
  mm <- model.matrix(~0 + group)
  colnames(mm) <- gsub("group", "", colnames(mm))  # cleaner names
  
  # Fit linear model
  fitted <- lmFit(expr, mm)
  
  # Build contrast (rbp vs Control)
  contrast_formula <- paste0(rbp, " - Control")
  contr <- makeContrasts(contrasts = contrast_formula, levels = colnames(coef(fitted)))
  
  tmp_contr <- contrasts.fit(fitted, contr)
  tmp <- eBayes(tmp_contr)
  
  # Get results
  top.table <- topTable(tmp, sort.by = "logFC", n=Inf)
  
  # Extract effect for this RBP (assuming rownames = genes)
  if (rbp %in% rownames(top.table)) {
    sh_effect <- top.table[rbp, , drop = FALSE]
  } else {
    sh_effect <- data.frame()
  }
  
  return(sh_effect)
}

# Loop over all RBPs
sh_effect_vector <- data.frame()
for (rbp in unique(Charm.object$Experiment)) {
  sh_effect <- shRNA_integrity(Charm.object, rbp, varoi = "SampleType")
  sh_effect_vector <- rbind(sh_effect_vector, sh_effect)
}

saveRDS(sh_effect_vector, "../Data_Objects/shRNA_Efficiency.Rds")
```
