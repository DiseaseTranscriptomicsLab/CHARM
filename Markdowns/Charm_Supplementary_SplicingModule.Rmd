---
title: "CHARM: Data Processing"
subtitle: "Comprehensive Hub for Alternative Regulatory Mapping"
author: 
  - name: "Alexandre Kaizeler^[Disease Transcriptomics Group, Gulbenkian Institute of Molecular Medicine]"
    email: alexandreafonso@gimm.pt
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  rmdformats::downcute:
    downcute_theme: "chaos"
---

# General

## Import libraries

```{r libraries, echo=FALSE}
# These are all the libraries I used throughout the analysis. Not all of them will be required on this guidebook
library(Rsubread)
library(limma)
library(edgeR)
library(DESeq2)
library(magrittr)
library(ggrepel)
library(tidyverse)
library(vsn)
library(ggplot2)
library(NMF)
library(biomaRt)
library(ggpubr)
library(factoextra)
library(ggfortify)
library(plotly)
library(reshape2)
library(fgsea)
library(msigdbr)
library(data.table)
library(colorspace)
library(readxl)
library(fs)
library(betAS)

set.seed(1906)
```

# A. Data Processing 

*Date: August 22th 2025*

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup

### Import data

To create the R object that we will use for CHARM, we need three data types:

Expression: Differential expression upon RBP knockdown/knockout, with pathway-level insights from Gene Set Enrichment Analysis.

Splicing: Alternative splicing changes quantified with betAS (Ferreira et al., 2024), using VastDB nomenclature (Tapial et al., 2017).

Binding: Altered RNA binding patterns of the silenced RBP and other RBPs, characterized with the eCLIPSE tool.

### Splicing

Preparation of the read count table, of K562 and HEPG2 cells exposed to knockdown/knockout of RBP and their respective control. All of these samples were obtained from the ENCODE project (Luo et al., 2020), and processed through the vast-tools pipeline (Tapial et al., 2017). The nomenculature of these splicing events is thus the one present on vastDB. 

```{r}
#All of these different raw counts were obtained on an RBP by RBP basis. They are separated by folders. First I will create a list with all of this information.
#By nature, Bowtie also gives us FPKM. I will focus on Counts, and so will remove all unnecessary information. For rows with the same gene names, I simply merge the counts together.
#You will notice the function has some failsafe parts to note errors where there was some human error on my part. 
#In theory, this should be fine now.

process_shRNAExp <- function(base_path = "~/Projects/StressGranules/AS.WC_Transcriptome/shRNAExp") {
  rbp_dirs <- list.dirs(base_path, recursive = FALSE, full.names = TRUE)
  CharmObj_rbp <- list()
  
  for (rbp_dir in rbp_dirs) {
    rbp_name <- basename(rbp_dir)
    
    vast_files <- list.files(file.path(rbp_dir, "TrimmedSamples/vast_out"),
                             pattern = "^INCLUSION_LEVELS.*$",
                             full.names = TRUE)
    
    if (length(vast_files) == 0) {
      warning(paste("No INCLUSION_LEVELS file found for", rbp_name, "skipping..."))
      next
    }
    
    vast_file <- vast_files[1]
    
    dataset <- getDataset(pathTables = vast_file, tool = "vast-tools")
    dataset <- getEvents(dataset, tool = "vast-tools")
    dataset_filtered <- filterEvents(dataset, types = c("S", "IR"), N = 0)
    dataset_filtered$PSI <- na.omit(dataset_filtered$PSI)
    dataset_filtered$Qual <- dataset_filtered$Qual[dataset_filtered$Qual$EVENT %in% dataset_filtered$PSI$EVENT, ]
    
    # --- Split into All / HEPG2 / K562 ---
    make_subset <- function(dataset, keyword) {
      out <- dataset
      out[["Samples"]] <- grep(keyword, out[["Samples"]], value = TRUE)
      
      psi_cols <- c(1:6, grep(keyword, colnames(out$PSI)))
      qual_cols <- c(1:6, grep(keyword, colnames(out$Qual)))
      out$PSI <- out$PSI[, psi_cols, drop = FALSE]
      out$Qual <- out$Qual[, qual_cols, drop = FALSE]
      return(out)
    }
    
    dataset_All   <- dataset_filtered
    dataset_HEPG2 <- make_subset(dataset_filtered, "HEPG2")
    dataset_K562  <- make_subset(dataset_filtered, "K562")
    

    CharmObj_rbp[[rbp_name]] <- list(
      All   = dataset_All,
      HEPG2 = dataset_HEPG2,
      K562  = dataset_K562
    )
  }
  
  return(CharmObj_rbp)
}

# Run it
CharmObj_rbp <- process_shRNAExp()

# Split into three objects
CharmObj_rbp_All   <- lapply(CharmObj_rbp, function(x) x$All)
CharmObj_rbp_HEPG2 <- lapply(CharmObj_rbp, function(x) x$HEPG2)
CharmObj_rbp_K562  <- lapply(CharmObj_rbp, function(x) x$K562)

# Save separately
saveRDS(CharmObj_rbp_All,   file = "~/Projects/CHARM/data/CharmObj_rbp_All.rds")
saveRDS(CharmObj_rbp_HEPG2, file = "~/Projects/CHARM/data/CharmObj_rbp_HEPG2.rds")
saveRDS(CharmObj_rbp_K562,  file = "~/Projects/CHARM/data/CharmObj_rbp_K562.rds")

CharmObj_rbp_All <- readRDS("~/Projects/CHARM/data/CharmObj_rbp_All.rds")
CharmObj_rbp_HEPG2 <- readRDS("~/Projects/CHARM/data/CharmObj_rbp_HEPG2.rds")
CharmObj_rbp_K562 <- readRDS("~/Projects/CHARM/data/CharmObj_rbp_K562.rds")
```

### Filtering

```{r}
NewFilterFunction <- function (filteredList, eventlist) 
{
  alternative <- list()
  psiTable <- filteredList$PSI
  qualTable <- filteredList$Qual
  originalColN <- ncol(psiTable)
  psi <- psiTable[, -c(1:6)]
  psiTable <- psiTable[psiTable$EVENT %in% eventlist$EVENT, ]
  qualTable <- qualTable[match(psiTable$EVENT, qualTable$EVENT), 
    ]
  psiTable <- psiTable[, c(1:originalColN)]
  qualTable <- qualTable[, c(1:originalColN)]
  alternative[[1]] <- psiTable
  alternative[[2]] <- qualTable
  alternative[[3]] <- table(psiTable$COMPLEX)
  alternative[[4]] <- colnames(psiTable)[-c(1:6)]
  names(alternative) <- c("PSI", "Qual", "EventsPerType", 
    "Samples")
  return(alternative)
}

FullTrial <- fread( "~/Projects/StressGranules/AS.WC_Transcriptome/eCLIPSE/FullCassetteEvents.txt")
```


```{r}
#BOTH
CharmObj_rbp_All_filtered <- list()
for (rbp in names(CharmObj_rbp_All)){
  dataset_All <- CharmObj_rbp_All[[rbp]]
  CharmObj_rbp_All_filtered[[rbp]]<- NewFilterFunction(dataset_All, FullTrial)
}
saveRDS(CharmObj_rbp_All_filtered,   file = "~/Projects/CHARM/data/CharmObj_rbp_All.rds")

CharmObj_rbp_All <- readRDS("~/Projects/CHARM/data/CharmObj_rbp_All.rds")

#K562
CharmObj_rbp_All_filtered <- list()
for (rbp in names(CharmObj_rbp_K562)){
  dataset_All <- CharmObj_rbp_K562[[rbp]]
  CharmObj_rbp_All_filtered[[rbp]]<- NewFilterFunction(dataset_All, FullTrial)
}
saveRDS(CharmObj_rbp_All_filtered,   file = "~/Projects/CHARM/data/CharmObj_rbp_K562.rds")

CharmObj_rbp_K562 <- readRDS("~/Projects/CHARM/data/CharmObj_rbp_K562.rds")

#HEPG2
CharmObj_rbp_All_filtered <- list()
for (rbp in names(CharmObj_rbp_HEPG2)){
  dataset_All <- CharmObj_rbp_HEPG2[[rbp]]
  CharmObj_rbp_All_filtered[[rbp]]<- NewFilterFunction(dataset_All, FullTrial)
}
saveRDS(CharmObj_rbp_All_filtered,   file = "~/Projects/CHARM/data/CharmObj_rbp_HEPG2.rds")

CharmObj_rbp_HEPG2 <- readRDS("~/Projects/CHARM/data/CharmObj_rbp_HEPG2.rds")
```

### Differential Splicing

```{r}
for (rbp in names(CharmObj_rbp_All)) {
  dataset_All_filtered <- CharmObj_rbp_All[[rbp]]
  psi <- dataset_All_filtered$PSI
  qual <- dataset_All_filtered$Qual
  
  # --- Automatically detect control and shRNA columns ---
  cols_CTRL_names <- grep("control", colnames(psi), value = TRUE, ignore.case = TRUE)
  cols_shRNA_names <- grep("shrna", colnames(psi), value = TRUE, ignore.case = TRUE)
  
  # Skip safely if nothing is found
  if (length(cols_CTRL_names) == 0 || length(cols_shRNA_names) == 0) {
    message("⚠️  Skipping ", rbp, ": no control or shRNA columns found.")
    next
  }
  
  # Convert to column indices for betAS
  cols_CTRL <- convertCols(psi, cols_CTRL_names)
  cols_shRNA <- convertCols(psi, cols_shRNA_names)
  
  # --- Build volcano table ---
  volcanoTable_Pdiff_All <- tryCatch({
    prepareTableVolcano(
      psitable = psi,
      qualtable = qual,
      npoints = 500,
      colsA = cols_CTRL,
      colsB = cols_shRNA,
      labA = "CTRL",
      labB = "shRNA",
      basalColor = "#89C0AE",
      interestColor = "#E69A9C",
      maxDevTable = maxDevSimulationN100,
      seed = TRUE,
      CoverageWeight = FALSE
    )
  }, error = function(e) {
    message("⚠️  Skipping ", rbp, " due to error: ", e$message)
    return(NULL)
  })
  
  # Skip if failed
  if (is.null(volcanoTable_Pdiff_All)) next
  
  # --- Format output ---
  volcanoTable_Pdiff_All <- volcanoTable_Pdiff_All[, c("EVENT", "GENE", "deltapsi", "Pdiff")]
  colnames(volcanoTable_Pdiff_All) <- c("Event.ID", "Gene", "dPSI", "Pdiff")
  
  # --- Store result ---
  CharmObj_rbp_All[[rbp]]$VulcanTable <- volcanoTable_Pdiff_All
}

```

# Vulcan Tables Completed

```{r}
saveRDS(Charm.object, "~/Projects/CHARM/data/Charm.object.RDS")
saveRDS(Charm.object_K562, "~/Projects/CHARM/data/Charm.object_K562.RDS")
saveRDS(Charm.object_HEPG2, "~/Projects/CHARM/data/Charm.object_HEPG2.RDS")
```

# Violin Plots

```{r}

violin_splice_plot <- function(Charmobj, rbp) {
  dpsi_table <- Charmobj[[rbp]]$VulcanTable
  if (is.null(dpsi_table)) {
    message("⚠️ No VulcanTable found for ", rbp)
    return(NULL)
  }

  # Add splicing type info
  dpsi_table <- dpsi_table %>%
    mutate(Type = case_when(
      startsWith(Event.ID, "HsaEX")  ~ "ES",
      startsWith(Event.ID, "HsaINT") ~ "IR",
      TRUE                           ~ NA_character_
    )) %>%
    filter(!is.na(Type))  # Clean up

  # Calculate average ΔPSI by type
  avg_vals <- dpsi_table %>%
    group_by(Type) %>%
    summarise(mean_dPSI = mean(dPSI, na.rm = TRUE)) %>%
    pivot_wider(names_from = Type, values_from = mean_dPSI)

  # Build subtitle text
  subtitle_text <- paste0(
    "Mean ΔPSI — ES: ",
    sprintf("%.3f", avg_vals$ES),
    " | IR: ",
    sprintf("%.3f", avg_vals$IR)
  )

  # Make the plot
  
ggplot(dpsi_table, aes(x = Type, y = dPSI))  +
           # Violin plot
  geom_jitter(width = 0.2, alpha = 0.6, size = 1.5) +geom_violin(alpha=.7) +
    theme_minimal() +
    ylab("ΔPSI (shRNA - CTRL)") +
    xlab("Event Type") +
    ggtitle(paste0(rbp), subtitle = subtitle_text) +
    coord_flip() +
    geom_hline(yintercept = 0, linetype = "dashed") +
    theme(
      plot.title = element_text(hjust = 0.5),
      text = element_text(size = 20, family = "Arial MS"),
      plot.subtitle = element_text(hjust = 0.5)
    )
}


violin_splice_plot(Charm.object, "RBFOX2")
```

# Volcano Plot

```{r}

plot_splice_volcano <- function(charmobj, rbp, other_events = NULL) {
  # Extract volcano data for RBP
  top.table <- charmobj[[rbp]]$VulcanTable
  if (is.null(top.table)) {
    message("⚠️ No VulcanTable found for ", rbp)
    return(NULL)
  }
  
  # Add highlight flag
  top.table <- top.table %>%
    mutate(highlight = ifelse(Event.ID %in% other_events, "Other", "None"))
  
  # Order by absolute dPSI for better plotting
  top.table <- top.table %>% arrange(desc(abs(dPSI)))
  
  # Volcano plot
  volcano_plot <- ggplot(top.table, aes(x = dPSI, y = Pdiff)) +
    geom_point(data = subset(top.table, highlight == "None"),
               color = "#CCCCCC", alpha = 0.6) +
    geom_point(data = subset(top.table, highlight == "Other"),
               color = "#23586C", alpha = 0.8, size = 2) +
    geom_text_repel(
      data = subset(top.table, highlight == "Other"),
      aes(label = Gene),  # ✅ label each highlighted point by Gene name
      size = 3.5, fontface = "italic", color = "#23586C", nudge_y = 0.5
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14),
      axis.title = element_text(size = 12),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      legend.position = "none"
    ) +
    labs(
      title = paste("Volcano Plot:", rbp),
      x = "ΔPSI (shRNA - CTRL)",
      y = "PDiff"
    )
  
  return(list(top_table = top.table, volcano_plot = volcano_plot))
}

# Example usage:
rbp <- "RBFOX2"
result <- plot_splice_volcano(Charm.object, rbp, other_events = c("HsaEX0001234", "HsaINT0005678"))

# View data and plot
head(result$top_table)
result$volcano_plot




```

# B. Similarity

### Functions

#### Heatmap

```{r}

splicing_correl <- function(charmobj, rbp, correl_num = NULL,
                            n_pos = NULL, n_neg = NULL, other_rbps = NULL) {
  # --- Input check ---
  if (!(rbp %in% names(charmobj))) {
    stop("RBP not found in provided object")
  }

  rbp_label <- rbp

  # Reference table: Event.ID and dPSI
  ref_df <- charmobj[[rbp_label]]$VulcanTable[, c("Event.ID", "dPSI")]
  colnames(ref_df) <- c("Event.ID", "dPSI") # ensure names
  if (is.null(ref_df) || nrow(ref_df) == 0) {
    stop("No VulcanTable found or empty for RBP: ", rbp_label)
  }

  # Prepare cor_results
  cor_results <- data.frame(RBP = character(), Correlation = numeric(), Pvalue = numeric(), stringsAsFactors = FALSE)

  # correlate with every other RBP in charmobj
  for (other_rbp in setdiff(names(charmobj), rbp_label)) {
    other_df <- charmobj[[other_rbp]]$VulcanTable[, c("Event.ID", "dPSI")]
    if (is.null(other_df) || nrow(other_df) == 0) next

    merged <- merge(ref_df, other_df, by = "Event.ID", suffixes = c("_ref", "_other"))
    if (nrow(merged) > 2) {
      test <- suppressWarnings(cor.test(merged$dPSI_ref, merged$dPSI_other, method = "spearman"))
      cor_results <- rbind(cor_results,
                           data.frame(RBP = other_rbp,
                                      Correlation = unname(test$estimate),
                                      Pvalue = test$p.value,
                                      stringsAsFactors = FALSE))
    }
  }

  # If no correlations computed, return empty result
  if (nrow(cor_results) == 0) {
    message("No valid correlations computed (not enough overlapping events).")
    return(list(correlation_table = cor_results,
                top_table = cor_results,
                heatmap = NULL))
  }

  # Prepare sorted views
  pos <- cor_results[order(-cor_results$Correlation), ]
  neg <- cor_results[order(cor_results$Correlation), ]

  # --- Select top RBPs (mirror original logic) ---
  if (!is.null(other_rbps)) {
    # warn about invalid names
    not_found <- setdiff(other_rbps, cor_results$RBP)
    if (length(not_found) > 0) {
      for (name in not_found) {
        message("'", name, "' is not a valid RBP name (or had no overlap).")
      }
    }
    valid_rbps <- intersect(other_rbps, cor_results$RBP)
    top_cor <- cor_results[cor_results$RBP %in% valid_rbps, ]

  } else if (!is.null(correl_num) && !is.na(correl_num) && correl_num > 0) {
    # top by absolute correlation
    top_cor <- head(cor_results[order(-abs(cor_results$Correlation)), ], correl_num)

  } else if ((!is.null(n_pos) && !is.na(n_pos) && n_pos > 0) ||
             (!is.null(n_neg) && !is.na(n_neg) && n_neg > 0)) {

    top_pos <- if (!is.null(n_pos) && !is.na(n_pos) && n_pos > 0) head(pos, n_pos) else NULL
    top_neg <- if (!is.null(n_neg) && !is.na(n_neg) && n_neg > 0) head(neg, n_neg) else NULL
    top_cor <- rbind(top_pos, top_neg)

  } else {
    stop("Please provide either other_rbps, correl_num, or (n_pos and/or n_neg)")
  }

  # Order and factorize for plotting
  top_cor <- top_cor[order(top_cor$Correlation, decreasing = TRUE), ]
  top_cor$RBP <- factor(top_cor$RBP, levels = top_cor$RBP)

  # --- Heatmap plot ---
  heatmap_plot <- ggplot(top_cor, aes(x = rbp_label, y = RBP, fill = Correlation)) +
    geom_tile(color = "white") +
    geom_text(aes(label = sprintf("%.2f", Correlation),
                  color = ifelse(abs(Correlation) < 0.3, "black", "white")),
              size = 5) +
    scale_color_identity() +
    scale_fill_gradient2(low = "black", mid = "grey50", high = "#601700",
                         midpoint = 0, limits = c(-1, 1)) +
    labs(title = paste("Spearman correlations with", rbp_label, "- ΔPSI"),
         x = "Reference RBP", y = "Other RBPs") +
    theme_minimal(base_size = 14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))

  return(list(correlation_table = cor_results,
              top_table = top_cor,
              heatmap = heatmap_plot))
}

result <- splicing_correl(Charm.object, "RBFOX2", other_rbps = c("TIA1", "PTBP1", "QKI"))
result$top_table
result$heatmap

```

#### Scatter

```{r}
correl_scatter_splicing <- function(charmobj, rbp, other_rbp) {
  #----------------------------
  # Step 1: Input checks
  #----------------------------
  if (!(rbp %in% names(charmobj))) {
    stop(paste("'", rbp, "' not found in charmobj"))
  }
  if (!(other_rbp %in% names(charmobj))) {
    stop(paste("'", other_rbp, "' not found in charmobj"))
  }
  
  ref_df <- charmobj[[rbp]]$VulcanTable
  other_df <- charmobj[[other_rbp]]$VulcanTable
  
  # Ensure required columns
  stopifnot(all(c("Event.ID", "dPSI") %in% colnames(ref_df)))
  stopifnot(all(c("Event.ID", "dPSI") %in% colnames(other_df)))
  
  #----------------------------
  # Step 2: Merge data
  #----------------------------
  merged <- merge(ref_df[, c("Event.ID", "dPSI")],
                  other_df[, c("Event.ID", "dPSI")],
                  by = "Event.ID",
                  suffixes = c(paste0("_", rbp), paste0("_", other_rbp)))
  
  if (nrow(merged) < 3) {
    stop("Not enough overlapping events between ", rbp, " and ", other_rbp)
  }
  
  #----------------------------
  # Step 3: Correlation test
  #----------------------------
  cor_test <- suppressWarnings(cor.test(merged[[paste0("dPSI_", rbp)]],
                                        merged[[paste0("dPSI_", other_rbp)]],
                                        method = "spearman"))
  rho <- unname(cor_test$estimate)
  pval <- cor_test$p.value
  
  #----------------------------
  # Step 4: Scatter plot
  #----------------------------
  p <- ggplot(merged, aes_string(x = paste0("dPSI_", rbp), y = paste0("dPSI_", other_rbp))) +
    geom_point(fill = "#DDDDDD", alpha = 0.4, size = 4, shape = 21, colour = "black") +
    geom_density2d(color = "#800020", size = 1.2) +
    theme_bw() +
    xlab(paste(rbp, "ΔPSI")) +
    ylab(paste(other_rbp, "ΔPSI")) +
    ggtitle(paste("ΔPSI Correlation between", rbp, "and", other_rbp)) +
    theme(
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      panel.grid.major = element_blank(),
      plot.title = element_text(hjust = 0.5),
      text = element_text(size = 18, family = "Arial")
    ) +
    annotate("text", x = Inf, y = -Inf,
             hjust = 1.1, vjust = -1,
             label = sprintf("Spearman ρ = %.2f\np = %.2e", rho, pval),
             size = 5, fontface = "bold", color = "#800020")
  
  #----------------------------
  # Step 5: Return
  #----------------------------
  return(list(plot = p,
              correlation = rho,
              pvalue = pval,
              merged_data = merged))
}

correl_scatter_splicing(Charm.object, "RBFOX2", "TIA1")
```

# C. Event Centered Expression

```{r}
available.events <- unique(unlist(lapply(as.character(names(Charm.object_K562)), function(rbp) {
  obj <- Charm.object_K562[[rbp]]
  
  if (is.null(obj)) {
    warning(paste("No entry for", rbp))
    return(NULL)
  }
  
  df <- obj[["VulcanTable"]]
  
  if (is.null(df)) {
    warning(paste("No VulcanTable for", rbp))
    return(NULL)
  }
  
  df$Event.ID
})))

saveRDS(available.events, "~/Projects/CHARM/data/AvailableEvents_K562.RDS")


plot_event_dpsi_heatmap <- function(CharmObj, Event.ID) {

  # Extract dPSI for the Event.ID across all RBPs safely
  dPSI_data <- lapply(names(CharmObj), function(rbp) {
    df <- CharmObj[[rbp]]$VulcanTable

    # Validate structure
    if (!is.null(df) && "dPSI" %in% colnames(df) && "Event.ID" %in% colnames(df)) {
      # find rows matching the Event.ID
      hits <- which(df$Event.ID == Event.ID)

      if (length(hits) == 1) {
        data.frame(RBP = rbp, dPSI = as.numeric(df$dPSI[hits]), stringsAsFactors = FALSE)
      } else if (length(hits) > 1) {
        # If multiple entries for the same Event.ID, take the first (or change strategy)
        data.frame(RBP = rbp, dPSI = as.numeric(df$dPSI[hits[1]]), stringsAsFactors = FALSE)
      } else {
        data.frame(RBP = rbp, dPSI = NA_real_, stringsAsFactors = FALSE)
      }
    } else {
      data.frame(RBP = rbp, dPSI = NA_real_, stringsAsFactors = FALSE)
    }
  }) %>%
    bind_rows() %>%
    drop_na(dPSI)

  # Check that we found the Event.ID somewhere
  if (nrow(dPSI_data) == 0) {
    stop(paste0("Event '", Event.ID, "' not found in any RBP GSEA tables."))
  }

  # Select top 10 and bottom 10
  top10 <- dPSI_data %>% arrange(desc(dPSI)) %>% slice_head(n = 10)
  bottom10 <- dPSI_data %>% arrange(dPSI) %>% slice_head(n = 10)
  selected <- bind_rows(top10, bottom10)

  # Create a column to use as x-axis (single column heatmap)
  selected$Event.ID <- Event.ID

  # Order RBPs by NES for visualization (from low -> high)
  selected$RBP <- factor(selected$RBP, levels = selected$RBP[order(selected$dPSI)])

  # Build and return the plot
  p <- ggplot(selected, aes(x = Event.ID, y = RBP, fill = dPSI)) +
    geom_tile(color = "white") +
    geom_text(aes(label = sprintf("%.2f", dPSI)), color = "white", size = 5) +
    scale_fill_gradient2(low = "black", mid = "white", high = "#601700", midpoint = 0) +
    labs(
      title = paste0("Top/bottom RBPs by NES for ", Event.ID),
      x = "", y = "RBP"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      axis.ticks.x = element_blank(),
      axis.text.x = element_text(face = "italic")  # italic x-axis label (the geneset)
    )

  return(p)
}

plot_event_dpsi_heatmap(Charm.object, "HsaEX0056692")
```
