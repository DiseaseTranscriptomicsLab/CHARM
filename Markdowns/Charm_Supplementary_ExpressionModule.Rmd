---
title: "CHARM: Data Processing"
subtitle: "Comprehensive Hub for Alternative Regulatory Mapping"
author: 
  - name: "Alexandre Kaizeler^[Disease Transcriptomics Group, Gulbenkian Institute of Molecular Medicine]"
    email: alexandreafonso@gimm.pt
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  rmdformats::downcute:
    downcute_theme: "chaos"
---

# General

## Import libraries

```{r libraries, echo=FALSE}
# These are all the libraries I used throughout the analysis. Not all of them will be required on this guidebook
library(Rsubread)
library(limma)
library(edgeR)
library(DESeq2)
library(magrittr)
library(ggrepel)
library(tidyverse)
library(vsn)
library(ggplot2)
library(NMF)
library(biomaRt)
library(ggpubr)
library(factoextra)
library(ggfortify)
library(plotly)
library(reshape2)
library(fgsea)
library(msigdbr)
library(data.table)
library(colorspace)
library(readxl)
library(fs)

set.seed(1906)
```

# A. Data Processing 

*Date: August 19th 2025*

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Setup

### Import data

To create the R object that we will use for CHARM, we need three data types:

Expression: Differential expression upon RBP knockdown/knockout, with pathway-level insights from Gene Set Enrichment Analysis.

Splicing: Alternative splicing changes quantified with betAS (Ferreira et al., 2024), using VastDB nomenclature (Tapial et al., 2017).

Binding: Altered RNA binding patterns of the silenced RBP and other RBPs, characterized with the eCLIPSE tool.

#### Expression

Preparation of the read count table, of K562 and HEPG2 cells exposed to knockdown/knockout of RBP and their respective control. All of these samples were obtained from the ENCODE project (Luo et al., 2020), and processed through the vast-tools pipeline (Tapial et al., 2017). As such, the raw fastq samples obtained from ENCODE were aligned with Bowtie.

```{r}
#All of these different raw counts were obtained on an RBP by RBP basis. They are separated by folders. First I will create a list with all of this information.
#By nature, Bowtie also gives us FPKM. I will focus on Counts, and so will remove all unnecessary information. For rows with the same gene names, I simply merge the counts together.
#You will notice the function has some failsafe parts to note errors where there was some human error on my part. 
#In theory, this should be fine now.

build_rawcounts_list <- function(
  base_path = "~/Projects/StressGranules/AS.WC_Transcriptome/shRNAExp"
) {
  base_path <- fs::path_expand(base_path)

  subdirs <- fs::dir_ls(base_path, type = "directory", recurse = FALSE)
  folder_names <- fs::path_file(subdirs)

  out <- setNames(
    lapply(folder_names, function(folder) {
      vast_dir <- fs::path(base_path, folder, "TrimmedSamples", "vast_out")
      if (!fs::dir_exists(vast_dir)) {
        message("Missing directory: ", vast_dir)
        return(list(rawcounts = NULL))
      }

      matches <- fs::dir_ls(vast_dir, type = "file", regexp = "cRPKM_AND_COUNTS")
      if (length(matches) == 0) {
        message("No 'cRPKM_AND_COUNTS' file in: ", vast_dir)
        return(list(rawcounts = NULL))
      }
      if (length(matches) > 1) {
        info <- fs::file_info(matches)
        matches <- matches[order(info$modification_time, decreasing = TRUE)]
        message("Multiple matches in ", vast_dir, "; using latest: ", fs::path_file(matches[1]))
      }

      dt <- data.table::fread(matches[1])

      # --- 1) Drop columns named exactly "ID" or containing "RPKM"
      cols_to_drop <- grep("^ID$|RPKM", names(dt), value = TRUE)
      if (length(cols_to_drop) > 0) {
        dt[, (cols_to_drop) := NULL]
      }

      # --- 2) Normalise "Name" column casing and aggregate duplicates (NA -> 0)
      name_idx <- which(tolower(names(dt)) == "name")
      if (length(name_idx) == 1L) {
        setnames(dt, name_idx, "Name")
      }
      if ("Name" %in% names(dt)) {
        num_cols <- names(dt)[vapply(dt, is.numeric, logical(1))]
        dt <- dt[, lapply(.SD, function(x) sum(x, na.rm = TRUE)), by = Name, .SDcols = num_cols]
      }

      # --- 3) Flag columns that CONTAIN a digits_digits substring anywhere (e.g. "1_1")
      suspicious_cols <- grep("\\d+_\\d+", names(dt), value = TRUE)
      if (length(suspicious_cols) > 0) {
        message("‚ö†Ô∏è Folder ", folder, " has columns with integer_integer substrings: ",
                paste(suspicious_cols, collapse = ", "))
      }

      list(rawcounts = dt)
    }),
    folder_names
  )

  out
}

# Run
#This creates the CharmObj
CharmObj_rbp <- build_rawcounts_list()
CharmObj_rbp_raw <- build_rawcounts_list()
```

#### Metadata

```{r}
add_metadata <- function(obj) {
  lapply(names(obj), function(folder) {
    rc <- obj[[folder]]$rawcounts
    
    if (is.null(rc)) {
      return(list(rawcounts = NULL, SampleType = NULL, Cell = NULL, Experiment = NULL))
    }
    
    cols <- names(rc)[-1]  # drop first column (Name)
    
    rc <- as.data.frame(rc)
    row.names(rc) <- rc$Name
    rc$Name <- NULL
    # SampleType
    sample_type <- vapply(cols, function(col) {
      if (grepl("control", col, ignore.case = TRUE)) {
        "Control"
      } else if (grepl("shrna", col, ignore.case = TRUE)) {
        folder
      } else {
        NA_character_
      }
    }, character(1))
    
    # Cell type
    cell <- vapply(cols, function(col) {
      if (grepl("K562", col, ignore.case = TRUE)) {
        "K562"
      } else if (grepl("HEPG2", col, ignore.case = TRUE)) {
        "HEPG2"
      } else {
        NA_character_
      }
    }, character(1))
    
    # Experiment: just the folder name repeated for all columns
    experiment <- rep(folder, length(cols))
    
    list(
      rawcounts  = rc,
      SampleType = sample_type,
      Cell       = cell,
      Experiment = experiment
    )
  }) |> setNames(names(obj))
}

# ---- Apply to your CharmObj ----
CharmObj_rbp <- add_metadata(CharmObj_rbp)
```

# B.1 Expression object

## Both Cell Lines

```{r}
for (rbp in names(CharmObj_rbp)) {
  
  Charm.object <- CharmObj_rbp[[rbp]]
  
  if (length(unique(Charm.object$Cell)) == 1){
    CharmObj_rbp[[rbp]] <- NULL
  }
}
    
```


##### Filtration (Density Plot)

In this version, every RBP is processed sepparetely, as if they were their own expression/tissue.

```{r}
for (rbp in names(CharmObj_rbp)) {
  
  Charm.object <- CharmObj_rbp[[rbp]]
  
  alternew <- log10(rowSums(Charm.object$rawcounts))
  alternew <- as.data.frame(alternew)
  
  ggplot(alternew, aes(x=alternew)) + geom_density() + theme_bw() + geom_vline(xintercept = 2.75, linetype = "dashed") + ylab("Events") + xlab("Number of Reads (log10)") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank()) + ggtitle("Density of Reads - All Samples")
  
  filterednew <- subset(Charm.object$rawcounts, alternew>2.75)
  
  
  #after cutting, its a good idea to visualize again
  falternew <- log10(rowSums(filterednew))
  falternew <- as.data.frame(falternew)
  ggplot(falternew, aes(x=falternew)) + geom_density() + theme_bw() + ylab("Events") + xlab("Number of Reads (log10)") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank())
  
  #lets save the genes which we maintain
  impgenes <- unique(c(row.names(falternew), unique(Charm.object$Experiment)))
  
  
  #Now we need to select only the rows which have those genes.
 CharmObj_rbp[[rbp]]$filtcounts <- Charm.object$rawcounts[row.names(Charm.object$rawcounts)%in%impgenes,]
  
  
}
```



##### Matrix Design

Good! Now we can proceed by designing our matrices. 

```{r}
for (rbp in names(CharmObj_rbp)) {
  
  Charm.object <- CharmObj_rbp[[rbp]]
  #To be able to use Voom, we must first convert our read count table into a special DGE object.
  D0 <- DGEList(Charm.object$filtcounts)
  
  
  #Then we calculate the normalisation factors for these new generated data frames
  #Bear in mind this step calculates the normalisation factors, but does not normalise itself.
  D0 <- calcNormFactors(D0)
  
  metadata <- data.frame(Sample=Charm.object$SampleType, Cell=Charm.object$Cell)
  
  
  #Now we do the matrixes
  
    mm <- model.matrix(~0+Sample+Cell, metadata)
  

  
  #and now we normalise. This step also turns our counts into log2-counts per million.
  y <- voom(D0, mm, plot = T)
  CharmObj_rbp[[rbp]]$normcounts <- as.data.frame(y$E)
  
}
```

##### Normalisation

Now, we are almost ready to move on to the differential gene expression analysis. I will first check to see if any issues arose during the normalisation process, by looking at samples before and after this process.

```{r}
for (rbp in names(CharmObj_rbp)) {
  Charm.object <- CharmObj_rbp[[rbp]]
# ----------------------------
# Prior to Normalisation
# ----------------------------
dfforboxy <- Charm.object$filtcounts

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")

prenorm <- ggplot(dfforboxy, aes(x = Sample, y = log2(Expression + 1))) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle("Prior to Normalisation")

# ----------------------------
# After Normalisation
# ----------------------------
dfforboxy <- Charm.object$normcounts

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")


postnorm <- ggplot(dfforboxy, aes(x = Sample, y = Expression)) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2CPM)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle(paste0("After Normalisation", rbp))

print(ggarrange(prenorm, postnorm, nrow = 1))
}
```

Normalisation isn't ideal, but it isn't too bad either.

##### Batch Correction

As an extra layer, we can also consider "cell type" as a batch factor. Here is the process I used to do so. For more information, please consult Schneider et al (voyAGEr).

```{r}
for (rbp in names(CharmObj_rbp)) {
  Charm.object <- CharmObj_rbp[[rbp]]

    metadata <- data.frame(Cell=Charm.object$Cell, Sample=Charm.object$SampleType)
batch_cols <- c("Cell")
metadata_cols <- c("Sample")
mmbatch <- model.matrix(reformulate(paste0("~0 + ",paste0( batch_cols,collapse = " + "))), data=metadata)
mmkeep <- model.matrix(reformulate(paste0("~0 + ",paste0( metadata_cols,collapse =  "+" ))), data=metadata)
mm <- cbind(mmkeep,mmbatch)
D0 <- DGEList(2^Charm.object$normcounts) 
D0 <- calcNormFactors(D0)
y <- voom(D0, mm, plot = F)
fit <- lmFit(y, mm)
beta <- fit$coefficients[,-(1:ncol(mmkeep)),drop=FALSE]
beta[is.na(beta)] <- 0
corrcounts_v1 <- as.matrix(y$E) - beta %*% t(mmbatch)
offset <- apply(corrcounts_v1,1,min) - apply(y$E,1,min)
corrcounts_v1 <- as.data.frame(corrcounts_v1-offset)
corrcounts_v1 <- 2^corrcounts_v1

mm <- model.matrix(~0+Sample, metadata)

y <- voom(corrcounts_v1, mm, plot = T)
CharmObj_rbp[[rbp]]$corcounts <- as.data.frame(y$E)

}
saveRDS(Charm.object, "../data/Charm.object.RDS")
```

#### Expression Violins

```{r}

violinplotter <- function(charmobj, rbp, control_color = "#7272AB", other_color = "#283D3B", highlight_color = "red") {
  # Get expression matrix
  expr <- charmobj[[rbp]]$corcounts
  expr <- expr[rbp,]
  df <- data.frame(Expression=t(expr), Group=charmobj[[rbp]]$SampleType)
  colnames(df) <- c("Expression", "Group")

# Compute mean expression per group
mean_expr <- df %>%
  group_by(Group) %>%
  summarise(mean_exp = mean(Expression, na.rm = TRUE))

# Log2 fold-change = difference of means (rbp - Control)
logFC <- mean_expr$mean_exp[mean_expr$Group == rbp] -
         mean_expr$mean_exp[mean_expr$Group == "Control"]

# Create plot
p <- ggplot(df, aes(x = Group, y = Expression, fill = Group)) +
  
  # All points (low alpha)
  geom_jitter(data = df, aes(x = Group, y = Expression),
              width = 0.15, alpha = 0.3, color = "#7272AB") +
  
  # Violin plot
  geom_violin(trim = FALSE, alpha = 0.6) +
  
  # Highlighted points on top
  geom_jitter(data = df[df$Highlight, ],
              aes(x = Group, y = Expression),
              width = 0.15, color = "#E54B4B", size = 3, alpha = 0.8) +
  
  # Fill colors for violins
  scale_fill_manual(values = c("Control" = "#7272AB", rbp = "#283D3B")) +
  
  # Labels and theme
  labs(
    title = paste("Expression of", rbp, "vs Control"),
    subtitle = paste0("Log2 Fold-Change: ", round(logFC, 2))
  ) +
  theme_bw() +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    text = element_text(size = 15, family = "Arial MS"),
    legend.position = "none"
  ) +
  xlab("") + ylab("Expression") +
  ylim(0, max(df$Expression) * 1.05)

return(p)

}

rbp <- "RBFOX2"
violinplotter(CharmObj_rbp, rbp)
```


#### Knockdown/knockout Integrity

I first check if indeed there is a knockdown of treated RBP.

```{r}

shRNA_integrity <- function(charmobj, rbp){
  # Expression matrix
  expr <- charmobj[[rbp]]$corcounts
  
  # Build design matrix
  group <- charmobj[[rbp]]$SampleType
  mm <- model.matrix(~0 + group)
  colnames(mm) <- gsub("group", "", colnames(mm))  # cleaner names
  
  # Fit linear model
  fitted <- lmFit(expr, mm)
  
  # Build contrast (rbp vs Control)
  contrast_formula <- paste0(rbp, " - Control")
  contr <- makeContrasts(contrasts = contrast_formula, levels = colnames(coef(fitted)))
  
  tmp_contr <- contrasts.fit(fitted, contr)
  tmp <- eBayes(tmp_contr)
  
  # Get results
  top.table <- topTable(tmp, sort.by = "logFC", n=Inf)
  
  # Extract effect for this RBP (assuming rownames = genes)
  if (rbp %in% rownames(top.table)) {
    sh_effect <- top.table[rbp, , drop = FALSE]
  } else {
    sh_effect <- data.frame()
  }
  
  return(sh_effect)
}

# Loop over all RBPs
sh_effect_vector <- data.frame()
for (rbp in names(CharmObj_rbp)) {
  sh_effect <- shRNA_integrity(CharmObj_rbp, rbp)
  sh_effect_vector <- rbind(sh_effect_vector, sh_effect)
}

saveRDS(sh_effect_vector, "../data/shRNA_Efficiency.Rds")
```


```{r}
rbp <- "RBFOX2"
ndegs <- 20
markers <- as.data.frame(sh_effect_vector[rbp,] )

ggplot(data = sh_effect_vector,
       aes(x = logFC, y = B)) +
  geom_point(color = "#CCCCCC") +
  geom_point(data = markers, aes(x = logFC, y = B), color = "#A10702", size = 5) +
  geom_label_repel(
    data = markers_to_plot,
    aes(label = rownames(markers_to_plot)),
    size = 4,
    point.padding = -0.5,
    color = "#A10702",
    max.overlaps = 20,
    fontface = "italic"
  ) +
  theme_bw() +
  xlab("Log Fold-Change") + 
  ylab("B-Statistic") +
  ggtitle("shRNA Effect") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),        # üöÄ removes all gridlines
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    text = element_text(size = 15, family = "Arial MS")
  )


```

#### Volcano 

```{r}

plot_rbp_volcano <- function(charmobj, rbp, other_genes = NULL) {
  #----------------------------
  # Step 1: Differential Expression
  #----------------------------
  # Expression matrix
  expr <- charmobj[[rbp]]$corcounts
  
  # Build design matrix
  group <- charmobj[[rbp]]$SampleType
  
  # Design matrix
  mm <- model.matrix(~0 + group)
  colnames(mm) <- gsub("group", "", colnames(mm))
  
  # Fit linear model
  fitted <- lmFit(expr, mm)
  
  # Contrast: RBP vs Control
  contrast_formula <- paste0(rbp, " - Control")
  contr <- makeContrasts(contrasts = contrast_formula, levels = colnames(coef(fitted)))
  
  tmp_contr <- contrasts.fit(fitted, contr)
  tmp <- eBayes(tmp_contr)
  
  # Get results for all genes
  top.table <- topTable(tmp, sort.by = "none", n = Inf)
  
  # Check provided genes
  if (!is.null(other_genes)) {
    not_found <- setdiff(other_genes, rownames(top.table))
    if (length(not_found) > 0) {
      for (gene in not_found) {
        message(paste0("The gene '", gene, "' was not found. This may be because of prior filtration."))
      }
    }
    other_genes <- intersect(other_genes, rownames(top.table))
  }
  
  # Add highlight categories
  top.table$highlight <- "None"
  top.table$highlight[rownames(top.table) == rbp] <- "RBP"
  if (!is.null(other_genes)) {
    top.table$highlight[rownames(top.table) %in% other_genes] <- "Other"
  }
  
  # Order by absolute t-statistic
  top.table <- top.table[order(-abs(top.table$t)), ]
  
  #----------------------------
  # Step 2: Volcano Plot
  #----------------------------
  volcano_plot <- ggplot() +
    # Base layer: all genes grey
    geom_point(data = subset(top.table, highlight == "None"),
               aes(x = logFC, y = B), color = "#CCCCCC", alpha = 0.6) +
    # Blue layer: other genes
    geom_point(data = subset(top.table, highlight == "Other"),
               aes(x = logFC, y = B), color = "#23586C", alpha = 0.8, size = 2) +
    # Red layer: rbp gene
    geom_point(data = subset(top.table, highlight == "RBP"),
               aes(x = logFC, y = B), color = "#A10702", alpha = 0.9, size = 2.5) +
    # Labels for RBP
    geom_text_repel(
      data = subset(top.table, highlight == "RBP"),
      aes(x = logFC, y = B, label = rownames(subset(top.table, highlight == "RBP"))),
      size = 5, fontface = "italic",color = "#A10702", nudge_y = 1
    ) +
    # Labels for Other genes
    geom_text_repel(
      data = subset(top.table, highlight == "Other"),
      aes(x = logFC, y = B, label = rownames(subset(top.table, highlight == "Other"))),
      size = 4, fontface = "italic", color = "#23586C", nudge_y = 1
    ) +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5),
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      legend.position = "none"
    ) +
    labs(title = paste("Volcano plot:", rbp),
         x = "Log2 Fold-Change", y = "B-statistic")
  
  return(list(top_table = top.table, volcano_plot = volcano_plot))
}

rbp <- "RBFOX2"
result <- plot_rbp_volcano(CharmObj_rbp, rbp)

# Get full DE table
head(result$top_table)

# Show volcano plot
result$volcano_plot

for (rbp in names(CharmObj_rbp)) {
CharmObj_rbp[[rbp]]$DEGenes <- plot_rbp_volcano(CharmObj_rbp, rbp)$top_table
}




```


#### GSEA 

```{r fig.height=6, fig.width=8}
plot_gsea <- function(charmobj, rbp, thresh = 0.05,
                      species = "Homo sapiens",
                      collection = "H", subcollection = NULL,
                      up_color = "#BA3B46", down_color = "#53A2BE",
                      show_legend = FALSE) {
  
  print(paste0("Calculating GSEA for ", rbp))
  #----------------------------
  # Step 1: Differential Expression
  #----------------------------
  # Expression matrix
  expr <- charmobj[[rbp]]$corcounts
  
  # Build design matrix
  group <- charmobj[[rbp]]$SampleType
  
  # Design matrix
  mm <- model.matrix(~0 + group)
  colnames(mm) <- gsub("group", "", colnames(mm))
  
  # Fit linear model
  fitted <- limma::lmFit(expr, mm)
  
  # Contrast: RBP vs Control
  contrast_formula <- paste0(rbp, " - Control")
  contr <- limma::makeContrasts(contrasts = contrast_formula, levels = colnames(coef(fitted)))
  
  tmp_contr <- limma::contrasts.fit(fitted, contr)
  tmp <- limma::eBayes(tmp_contr)
  
  # Get results for all genes
  top.table <- limma::topTable(tmp, sort.by = "none", n = Inf)
  
  #----------------------------
  # Step 2: Prepare ranks for GSEA
  #----------------------------
  DEGenes <- top.table[order(top.table$t, decreasing = TRUE), ]
  vectorranks <- DEGenes$t
  names(vectorranks) <- rownames(DEGenes)
  
  #----------------------------
  # Step 3: Load gene sets
  #----------------------------
  hallmarks.gs <- msigdbr(species = species, collection = collection, subcollection = subcollection)
  hallmarks.gsets <- split(hallmarks.gs$gene_symbol, hallmarks.gs$gs_name)
  hallmarks.gsets <- lapply(hallmarks.gsets, toupper)
  
  #----------------------------
  # Step 4: Run fgsea
  #----------------------------
  hallmarks.res <- fgsea(pathways = hallmarks.gsets, stats = vectorranks)
  
  hallmarks.res.tidy <- hallmarks.res %>%
    as_tibble() %>%
    arrange(desc(NES)) %>%
    mutate(Status = ifelse(NES > 0, "Upregulated", "Downregulated")) %>%
    arrange(padj) %>%
  mutate(pathway = gsub("^HALLMARK_", "", pathway))
  
  #----------------------------
  # Step 5: Filter significant results
  #----------------------------
  data_to_plot <- hallmarks.res.tidy %>% 
    filter(padj < thresh) %>%
    arrange(-abs(NES))
  
  #----------------------------
  # Step 6: Plot
  #----------------------------
  gsea_plot_hall <- ggplot(data_to_plot, aes(x = reorder(pathway, NES), y = NES)) +
    geom_col(aes(fill = Status), alpha = 0.8) +
    scale_fill_manual(values = c("Upregulated" = up_color, "Downregulated" = down_color)) +
    coord_flip() +
    labs(x = "Gene Set", 
         y = "Normalised Enrichment Score (NES)",
         title = "Enriched Gene Sets",
         subtitle = paste0("Comparison: ", rbp, "KD vs Control"),
         caption = paste0("padj < ", thresh)) +
    theme_bw(base_family = "Arial MS") +
    theme(
      plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5, size = 14),
      text = element_text(size = 14),
      legend.position = if (show_legend) "right" else "none"
    )
  
  #----------------------------
  # Return both results and plot
  #----------------------------
  return(list(geneset_table = hallmarks.res.tidy, gsea_plot = gsea_plot_hall))
}

result <- plot_gsea(CharmObj_rbp, "RBFOX2")

# Get full DE table
head(result$geneset_table)

# Show volcano plot
result$gsea_plot

for (rbp in names(CharmObj_rbp)) {
  CharmObj_rbp[[rbp]]$GSEA <- plot_gsea(CharmObj_rbp, rbp)$geneset_table
}

saveRDS(Charm.object, "../data/Charm.object.RDS")
```




# B.2 Expression Object

### Create CHARM Object (K562)

```{r}
add_metadata_K562 <- function(obj) {
  lapply(names(obj), function(folder) {
    rc <- obj[[folder]]$rawcounts
    
    if (is.null(rc)) {
      return(list(rawcounts = NULL, SampleType = NULL, Cell = NULL, Experiment = NULL))
    }
    
    rc <- as.data.frame(rc)
    row.names(rc) <- rc$Name
    rc$Name <- NULL
    
    cols <- colnames(rc)
    
    # --- Metadata construction ---
    sample_type <- vapply(cols, function(col) {
      if (grepl("control", col, ignore.case = TRUE)) {
        "Control"
      } else if (grepl("shrna", col, ignore.case = TRUE)) {
        folder
      } else {
        NA_character_
      }
    }, character(1))
    
    cell <- vapply(cols, function(col) {
      if (grepl("K562", col, ignore.case = TRUE)) {
        "K562"
      } else if (grepl("HEPG2", col, ignore.case = TRUE)) {
        "HEPG2"
      } else {
        NA_character_
      }
    }, character(1))
    
    experiment <- rep(folder, length(cols))
    
    # --- Filter only K562 samples ---
    k562_idx <- which(cell == "K562")
    if (length(k562_idx) == 0) {
      return(list(rawcounts = NULL, SampleType = NULL, Cell = NULL, Experiment = NULL))
    }
    
    rc <- rc[, k562_idx, drop = FALSE]
    sample_type <- sample_type[k562_idx]
    cell <- cell[k562_idx]
    experiment <- experiment[k562_idx]
    
    list(
      rawcounts  = rc,
      SampleType = sample_type,
      Cell       = cell,
      Experiment = experiment
    )
  }) |> setNames(names(obj))
}


# ---- Apply to your CharmObj ----
CharmObj_rbp_K562 <- add_metadata_K562(CharmObj_rbp_raw)

for (rbp in names(CharmObj_rbp_K562)) {
  
  Charm.object <- CharmObj_rbp_K562[[rbp]]
  
  if (length(unique(Charm.object$Cell)) != 1){
    CharmObj_rbp_K562[[rbp]] <- NULL
  }
}
    
```


##### Filtration (Density Plot)

In this version, every RBP is processed sepparetely, as if they were their own expression/tissue.

```{r}
for (rbp in names(CharmObj_rbp_K562)) {
  
  Charm.object <- CharmObj_rbp_K562[[rbp]]
  
  alternew <- log10(rowSums(Charm.object$rawcounts))
  alternew <- as.data.frame(alternew)
  
  ggplot(alternew, aes(x=alternew)) + geom_density() + theme_bw() + geom_vline(xintercept = 2.5, linetype = "dashed") + ylab("Events") + xlab("Number of Reads (log10)") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank()) + ggtitle("Density of Reads - All Samples")
  
  filterednew <- subset(Charm.object$rawcounts, alternew>2.5)
  
  
  #after cutting, its a good idea to visualize again
  falternew <- log10(rowSums(filterednew))
  falternew <- as.data.frame(falternew)
  ggplot(falternew, aes(x=falternew)) + geom_density() + theme_bw() + ylab("Events") + xlab("Number of Reads (log10)") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank())
  
  #lets save the genes which we maintain
  impgenes <- unique(c(row.names(falternew), unique(Charm.object$Experiment)))
  
  
  #Now we need to select only the rows which have those genes.
 CharmObj_rbp_K562[[rbp]]$filtcounts <- Charm.object$rawcounts[row.names(Charm.object$rawcounts)%in%impgenes,]
  
  
}
```



##### Matrix Design

Good! Now we can proceed by designing our matrices. 

```{r}
for (rbp in names(CharmObj_rbp_K562)) {
  
  Charm.object <- CharmObj_rbp_K562[[rbp]]
  #To be able to use Voom, we must first convert our read count table into a special DGE object.
  D0 <- DGEList(Charm.object$filtcounts)
  
  
  #Then we calculate the normalisation factors for these new generated data frames
  #Bear in mind this step calculates the normalisation factors, but does not normalise itself.
  D0 <- calcNormFactors(D0)
  
  metadata <- data.frame(Sample=Charm.object$SampleType)
  
  
  #Now we do the matrixes
  
    mm <- model.matrix(~0+Sample, metadata)
  

  
  #and now we normalise. This step also turns our counts into log2-counts per million.
  y <- voom(D0, mm, plot = T)
  CharmObj_rbp_K562[[rbp]]$normcounts <- as.data.frame(y$E)
  
}
```

##### Normalisation

Now, we are almost ready to move on to the differential gene expression analysis. I will first check to see if any issues arose during the normalisation process, by looking at samples before and after this process.

```{r}
for (rbp in names(CharmObj_rbp_K562)) {
  Charm.object <- CharmObj_rbp_K562[[rbp]]
# ----------------------------
# Prior to Normalisation
# ----------------------------
dfforboxy <- Charm.object$filtcounts

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")

prenorm <- ggplot(dfforboxy, aes(x = Sample, y = log2(Expression + 1))) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle("Prior to Normalisation")

# ----------------------------
# After Normalisation
# ----------------------------
dfforboxy <- Charm.object$normcounts

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")


postnorm <- ggplot(dfforboxy, aes(x = Sample, y = Expression)) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2CPM)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle(paste0("After Normalisation", rbp))

print(ggarrange(prenorm, postnorm, nrow = 1))
}
```

Normalisation isn't ideal, but it isn't too bad either.

##### Batch Correction

In here, we dont do batch correction, but to maintain the same structure as before, we simply add a new layer called corcounts

```{r}
for (rbp in names(CharmObj_rbp_K562)) {

CharmObj_rbp_K562[[rbp]]$corcounts <- CharmObj_rbp_K562[[rbp]]$normcounts

}
saveRDS(CharmObj_rbp_K562, "../data/Charm.object_K562.RDS")
```

#### Expression Violins

```{r}
rbp <- "RBFOX2"
violinplotter(CharmObj_rbp_K562, rbp)
```


#### Knockdown/knockout Integrity

I first check if indeed there is a knockdown of treated RBP.

```{r}
# Loop over all RBPs
sh_effect_vector <- data.frame()
for (rbp in names(CharmObj_rbp_K562)) {
  sh_effect <- shRNA_integrity(CharmObj_rbp_K562, rbp)
  sh_effect_vector <- rbind(sh_effect_vector, sh_effect)
}

saveRDS(sh_effect_vector, "../data/shRNA_Efficiency_K562.Rds")

```


```{r}
rbp <- "RBFOX2"
ndegs <- 20
markers_to_plot <- as.data.frame(sh_effect_vector[rbp,] )

ggplot(data = sh_effect_vector,
       aes(x = logFC, y = B)) +
  geom_point(color = "#CCCCCC") +
  geom_point(data = markers, aes(x = logFC, y = B), color = "#A10702", size = 5) +
  geom_label_repel(
    data = markers_to_plot,
    aes(label = rownames(markers_to_plot)),
    size = 4,
    point.padding = -0.5,
    color = "#A10702",
    max.overlaps = 20,
    fontface = "italic"
  ) +
  theme_bw() +
  xlab("Log Fold-Change") + 
  ylab("B-Statistic") +
  ggtitle("shRNA Effect") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),        # üöÄ removes all gridlines
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    text = element_text(size = 15, family = "Arial MS")
  )


```

#### Volcano 

```{r}
rbp <- "RBFOX2"
result <- plot_rbp_volcano(CharmObj_rbp_K562, rbp)

# Get full DE table
head(result$top_table)

# Show volcano plot
result$volcano_plot



for (rbp in names(CharmObj_rbp_K562)) {
CharmObj_rbp_K562[[rbp]]$DEGenes <- plot_rbp_volcano(CharmObj_rbp_K562, rbp)$top_table
}


  

```
#### GSEA 

```{r fig.height=6, fig.width=8}

rbp <- "RBFOX2"
result <- plot_gsea(CharmObj_rbp_K562, rbp)

# Get full DE table
head(result$geneset_table)

# Show volcano plot
result$gsea_plot

for (rbp in names(CharmObj_rbp_K562)) {
  CharmObj_rbp_K562[[rbp]]$GSEA <- plot_gsea(CharmObj_rbp_K562, rbp)$geneset_table
}

saveRDS(CharmObj_rbp_K562, "../data/Charm.object_K562.RDS")

```
# B.3 Expression Object

### Create CHARM Object (HEPG2)

```{r}
add_metadata_HEPG2 <- function(obj) {
  lapply(names(obj), function(folder) {
    rc <- obj[[folder]]$rawcounts
    
    if (is.null(rc)) {
      return(list(rawcounts = NULL, SampleType = NULL, Cell = NULL, Experiment = NULL))
    }
    
    rc <- as.data.frame(rc)
    row.names(rc) <- rc$Name
    rc$Name <- NULL
    
    cols <- colnames(rc)
    
    # --- Metadata construction ---
    sample_type <- vapply(cols, function(col) {
      if (grepl("control", col, ignore.case = TRUE)) {
        "Control"
      } else if (grepl("shrna", col, ignore.case = TRUE)) {
        folder
      } else {
        NA_character_
      }
    }, character(1))
    
    cell <- vapply(cols, function(col) {
      if (grepl("K562", col, ignore.case = TRUE)) {
        "K562"
      } else if (grepl("HEPG2", col, ignore.case = TRUE)) {
        "HEPG2"
      } else {
        NA_character_
      }
    }, character(1))
    
    experiment <- rep(folder, length(cols))
    
    # --- Filter only K562 samples ---
    HEPG2_idx <- which(cell == "HEPG2")
    if (length(HEPG2_idx) == 0) {
      return(list(rawcounts = NULL, SampleType = NULL, Cell = NULL, Experiment = NULL))
    }
    
    rc <- rc[, HEPG2_idx, drop = FALSE]
    sample_type <- sample_type[HEPG2_idx]
    cell <- cell[HEPG2_idx]
    experiment <- experiment[HEPG2_idx]
    
    list(
      rawcounts  = rc,
      SampleType = sample_type,
      Cell       = cell,
      Experiment = experiment
    )
  }) |> setNames(names(obj))
}


# ---- Apply to your CharmObj ----
CharmObj_rbp_HEPG2 <- add_metadata_HEPG2(CharmObj_rbp_raw)

for (rbp in names(CharmObj_rbp_HEPG2)) {
  
  Charm.object <- CharmObj_rbp_HEPG2[[rbp]]
  
  if (length(unique(Charm.object$Cell)) != 1){
    CharmObj_rbp_HEPG2[[rbp]] <- NULL
  }
}
    
```


##### Filtration (Density Plot)

In this version, every RBP is processed sepparetely, as if they were their own expression/tissue.

```{r}
for (rbp in names(CharmObj_rbp_HEPG2)) {
  
  Charm.object <- CharmObj_rbp_HEPG2[[rbp]]
  
  alternew <- log10(rowSums(Charm.object$rawcounts))
  alternew <- as.data.frame(alternew)
  
  ggplot(alternew, aes(x=alternew)) + geom_density() + theme_bw() + geom_vline(xintercept = 2.5, linetype = "dashed") + ylab("Events") + xlab("Number of Reads (log10)") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank()) + ggtitle("Density of Reads - All Samples")
  
  filterednew <- subset(Charm.object$rawcounts, alternew>2.5)
  
  
  #after cutting, its a good idea to visualize again
  falternew <- log10(rowSums(filterednew))
  falternew <- as.data.frame(falternew)
  ggplot(falternew, aes(x=falternew)) + geom_density() + theme_bw() + ylab("Events") + xlab("Number of Reads (log10)") +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank())
  
  #lets save the genes which we maintain
  impgenes <- unique(c(row.names(falternew), unique(Charm.object$Experiment)))
  
  
  #Now we need to select only the rows which have those genes.
 CharmObj_rbp_HEPG2[[rbp]]$filtcounts <- Charm.object$rawcounts[row.names(Charm.object$rawcounts)%in%impgenes,]
  
  
}
```



##### Matrix Design

Good! Now we can proceed by designing our matrices. 

```{r}
for (rbp in names(CharmObj_rbp_HEPG2)) {
  
  Charm.object <- CharmObj_rbp_HEPG2[[rbp]]
  #To be able to use Voom, we must first convert our read count table into a special DGE object.
  D0 <- DGEList(Charm.object$filtcounts)
  
  
  #Then we calculate the normalisation factors for these new generated data frames
  #Bear in mind this step calculates the normalisation factors, but does not normalise itself.
  D0 <- calcNormFactors(D0)
  
  metadata <- data.frame(Sample=Charm.object$SampleType)
  
  
  #Now we do the matrixes
  
    mm <- model.matrix(~0+Sample, metadata)
  

  
  #and now we normalise. This step also turns our counts into log2-counts per million.
  y <- voom(D0, mm, plot = T)
  CharmObj_rbp_HEPG2[[rbp]]$normcounts <- as.data.frame(y$E)
  
}
```

##### Normalisation

Now, we are almost ready to move on to the differential gene expression analysis. I will first check to see if any issues arose during the normalisation process, by looking at samples before and after this process.

```{r}
for (rbp in names(CharmObj_rbp_HEPG2)) {
  Charm.object <- CharmObj_rbp_HEPG2[[rbp]]
# ----------------------------
# Prior to Normalisation
# ----------------------------
dfforboxy <- Charm.object$filtcounts

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")

prenorm <- ggplot(dfforboxy, aes(x = Sample, y = log2(Expression + 1))) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle("Prior to Normalisation")

# ----------------------------
# After Normalisation
# ----------------------------
dfforboxy <- Charm.object$normcounts

dfforboxy <- reshape2::melt(dfforboxy)
colnames(dfforboxy) <- c("Sample", "Expression")


postnorm <- ggplot(dfforboxy, aes(x = Sample, y = Expression)) +
  geom_boxplot(alpha = 0.6) +
  theme_bw() +
  ylab("Read Counts (Log2CPM)") +
  xlab("Samples") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "None"
  ) +
  ggtitle(paste0("After Normalisation", rbp))

print(ggarrange(prenorm, postnorm, nrow = 1))
}
```

Normalisation isn't ideal, but it isn't too bad either.

##### Batch Correction

In here, we dont do batch correction, but to maintain the same structure as before, we simply add a new layer called corcounts

```{r}
for (rbp in names(CharmObj_rbp_HEPG2)) {

CharmObj_rbp_HEPG2[[rbp]]$corcounts <- CharmObj_rbp_HEPG2[[rbp]]$normcounts

}
saveRDS(CharmObj_rbp_HEPG2, "../data/Charm.object_HEPG2.RDS")
```

#### Expression Violins

```{r}
rbp <- "RBFOX2"
violinplotter(CharmObj_rbp_HEPG2, rbp)
```


#### Knockdown/knockout Integrity

I first check if indeed there is a knockdown of treated RBP.

```{r}
# Loop over all RBPs
# Loop over all RBPs
sh_effect_vector <- data.frame()
for (rbp in names(CharmObj_rbp_HEPG2)) {
  sh_effect <- shRNA_integrity(CharmObj_rbp_HEPG2, rbp)
  sh_effect_vector <- rbind(sh_effect_vector, sh_effect)
}

saveRDS(sh_effect_vector, "../data/shRNA_Efficiency_HEPG2.Rds")
```


```{r}
rbp <- "RBFOX2"
ndegs <- 20
markers_to_plot <- as.data.frame(sh_effect_vector[rbp,] )

ggplot(data = sh_effect_vector,
       aes(x = logFC, y = B)) +
  geom_point(color = "#CCCCCC") +
  geom_point(data = markers, aes(x = logFC, y = B), color = "#A10702", size = 5) +
  geom_label_repel(
    data = markers_to_plot,
    aes(label = rownames(markers_to_plot)),
    size = 4,
    point.padding = -0.5,
    color = "#A10702",
    max.overlaps = 20,
    fontface = "italic"
  ) +
  theme_bw() +
  xlab("Log Fold-Change") + 
  ylab("B-Statistic") +
  ggtitle("shRNA Effect") +
  theme(
    axis.line = element_line(colour = "black"),
    panel.grid = element_blank(),        # üöÄ removes all gridlines
    panel.border = element_blank(),
    panel.background = element_blank(),
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    text = element_text(size = 15, family = "Arial MS")
  )


```

#### Volcano 

```{r}
rbp <- "RBFOX2"
result <- plot_rbp_volcano(CharmObj_rbp_HEPG2, rbp)

# Get full DE table
head(result$top_table)

# Show volcano plot
result$volcano_plot



for (rbp in names(CharmObj_rbp_HEPG2)) {
CharmObj_rbp_HEPG2[[rbp]]$DEGenes <- plot_rbp_volcano(CharmObj_rbp_HEPG2, rbp)$top_table
}


  
```

#### GSEA 

```{r fig.height=6, fig.width=8}

rbp <- "RBFOX2"
result <- plot_gsea(CharmObj_rbp_HEPG2, rbp)

# Get full DE table
head(result$geneset_table)

# Show volcano plot
result$gsea_plot

for (rbp in names(CharmObj_rbp_HEPG2)) {
  CharmObj_rbp_HEPG2[[rbp]]$GSEA <- plot_gsea(CharmObj_rbp_HEPG2, rbp)$geneset_table
}

saveRDS(CharmObj_rbp_HEPG2, "../data/Charm.object_HEPG2.RDS")

```

# B.4 Similarity Object

### Functions

#### Expression

```{r}
exp_correl <- function(rbp_results, rbp, correl_num = 10,
                       n_pos = NULL, n_neg = NULL, other_rbps = NULL) {
  #----------------------------
  # Step 1: Extract the reference RBP
  #----------------------------
  if (!(rbp %in% names(rbp_results))) {
    stop("RBP not found in rbp_results")
  }
  
  ref_df <- rbp_results[[rbp]]
  stopifnot(all(c("Gene", "t") %in% colnames(ref_df)))
  ref_vec <- ref_df$t
  names(ref_vec) <- ref_df$Gene
  
  #----------------------------
  # Step 2: Correlate with all other RBPs
  #----------------------------
  cor_results <- data.frame(RBP = character(), Correlation = numeric(), Pvalue = numeric())
  
  for (other_rbp in setdiff(names(rbp_results), rbp)) {
    other_df <- rbp_results[[other_rbp]]
    merged <- merge(ref_df, other_df, by = "Gene", suffixes = c("_ref", "_other"))
    
    if (nrow(merged) > 2) {
      test <- suppressWarnings(cor.test(merged$t_ref, merged$t_other, method = "spearman"))
      cor_results <- rbind(
        cor_results,
        data.frame(RBP = other_rbp,
                   Correlation = unname(test$estimate),
                   Pvalue = test$p.value)
      )
    }
  }
  
  #----------------------------
  # Step 3: Select RBPs to plot
  #----------------------------
  if (!is.null(other_rbps)) {
    # Check which are valid
    not_found <- setdiff(other_rbps, names(rbp_results))
    if (length(not_found) > 0) {
      for (gene in not_found) {
        message(paste0("'", gene, "' is not a valid RBP name."))
      }
    }
    valid_rbps <- intersect(other_rbps, cor_results$RBP)
    top_cor <- cor_results[cor_results$RBP %in% valid_rbps, ]
    
  } else if (!is.null(correl_num)) {
    cor_results <- cor_results[order(-abs(cor_results$Correlation)), ]
    top_cor <- head(cor_results, correl_num)
    
  } else if (!is.null(n_pos) | !is.null(n_neg)) {
    pos <- cor_results[order(-cor_results$Correlation), ]
    neg <- cor_results[order(cor_results$Correlation), ]
    top_cor <- rbind(head(pos, n_pos), head(neg, n_neg))
    
  } else {
    stop("Please provide either other_rbps, correl_num, or (n_pos and/or n_neg)")
  }
  
  # Order rows by correlation strength
  top_cor <- top_cor[order(top_cor$Correlation, decreasing = TRUE), ]
  top_cor$RBP <- factor(top_cor$RBP, levels = top_cor$RBP)
  
  #----------------------------
  # Step 4: Heatmap
  #----------------------------
  heatmap_plot <- ggplot(top_cor, aes(x = rbp, y = RBP, fill = Correlation)) +
    geom_tile(color = "white") +
    geom_text(aes(label = sprintf("%.2f", Correlation)), color = "white", size = 5) +
    scale_fill_gradient2(low = "black", mid = "white", high = "#601700", midpoint = 0,
                         limits = c(-1, 1)) +
    labs(title = paste("Spearman correlations with", rbp, "- Expression"),
         x = "Reference RBP", y = "Other RBPs") +
    theme_minimal(base_size = 14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  return(list(correlation_table = cor_results,
              top_table = top_cor,
              heatmap = heatmap_plot))
}


```

#### GSEA

```{r}
gsea_correl <- function(gsea_results, rbp, correl_num = NULL,
                        n_pos = NULL, n_neg = NULL, other_rbps = NULL) {
  #----------------------------
  # Step 1: Extract the reference RBP
  #----------------------------
  if (!(rbp %in% names(gsea_results))) {
    stop("RBP not found in gsea_results")
  }
  
  ref_df <- gsea_results[[rbp]]
  stopifnot(all(c("pathway", "NES") %in% colnames(ref_df)))
  ref_vec <- ref_df$NES
  names(ref_vec) <- ref_df$pathway
  
  #----------------------------
  # Step 2: Correlate with all other RBPs
  #----------------------------
  cor_results <- data.frame(RBP = character(), Correlation = numeric(), Pvalue = numeric())
  
  for (other_rbp in setdiff(names(gsea_results), rbp)) {
    other_df <- gsea_results[[other_rbp]]
    merged <- merge(ref_df, other_df, by = "pathway", suffixes = c("_ref", "_other"))
    
    if (nrow(merged) > 2) {
      test <- suppressWarnings(cor.test(merged$NES_ref, merged$NES_other, method = "spearman"))
      cor_results <- rbind(
        cor_results,
        data.frame(RBP = other_rbp,
                   Correlation = unname(test$estimate),
                   Pvalue = test$p.value)
      )
    }
  }
  
  #----------------------------
  # Step 3: Select RBPs to plot
  #----------------------------
  if (!is.null(other_rbps)) {
    # Check which are valid
    not_found <- setdiff(other_rbps, names(gsea_results))
    if (length(not_found) > 0) {
      for (gene in not_found) {
        message(paste0("'", gene, "' is not a valid RBP name."))
      }
    }
    valid_rbps <- intersect(other_rbps, cor_results$RBP)
    top_cor <- cor_results[cor_results$RBP %in% valid_rbps, ]
    
  } else if (!is.null(correl_num)) {
    cor_results <- cor_results[order(-abs(cor_results$Correlation)), ]
    top_cor <- head(cor_results, correl_num)
    
  } else if (!is.null(n_pos) | !is.null(n_neg)) {
    pos <- cor_results[order(-cor_results$Correlation), ]
    neg <- cor_results[order(cor_results$Correlation), ]
    top_cor <- rbind(head(pos, n_pos), head(neg, n_neg))
    
  } else {
    stop("Please provide either other_rbps, correl_num, or (n_pos and/or n_neg)")
  }
  
  # Order rows by correlation strength
  top_cor <- top_cor[order(top_cor$Correlation, decreasing = TRUE), ]
  top_cor$RBP <- factor(top_cor$RBP, levels = top_cor$RBP)
  
  #----------------------------
  # Step 4: Heatmap
  #----------------------------
  heatmap_plot <- ggplot(top_cor, aes(x = rbp, y = RBP, fill = Correlation)) +
    geom_tile(color = "white") +
    geom_text(aes(label = sprintf("%.2f", Correlation)), color = "white", size = 5) +
    scale_fill_gradient2(low = "black", mid = "white", high = "#601700", midpoint = 0,
                         limits = c(-1, 1)) +
    labs(title = paste("Spearman correlations with", rbp, "- GSEA"),
         x = "Reference RBP", y = "Other RBPs") +
    theme_minimal(base_size = 14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  return(list(correlation_table = cor_results,
              top_table = top_cor,
              heatmap = heatmap_plot))
}


```

#### Scatters

##### Expression

```{r}
correl_exp_rbp <- function(rbp_results, rbp, other_rbp) {
  #----------------------------
  # Step 1: Input checks
  #----------------------------
  if (!(rbp %in% names(rbp_results))) {
    stop(paste("'", rbp, "' not found in rbp_results"))
  }
  if (!(other_rbp %in% names(rbp_results))) {
    stop(paste("'", other_rbp, "' not found in rbp_results"))
  }
  
  ref_df <- rbp_results[[rbp]]
  other_df <- rbp_results[[other_rbp]]
  
  stopifnot(all(c("Gene", "t") %in% colnames(ref_df)))
  stopifnot(all(c("Gene", "t") %in% colnames(other_df)))
  
  #----------------------------
  # Step 2: Merge data
  #----------------------------
  merged <- merge(ref_df, other_df, by = "Gene", suffixes = c(paste0("_", rbp), paste0("_", other_rbp)))
  
  #----------------------------
  # Step 3: Scatter plot with correlation
  #----------------------------
  p <- ggplot(merged, aes_string(x = paste0("t_", rbp), y = paste0("t_", other_rbp))) +
    geom_point(fill = "#DDDDDD", alpha = 0.3, size = 5, shape = 21, colour = "black") +
    geom_density2d(color = "#800020", size = 1.2) +
    theme_bw() +
    xlab(paste(rbp, "t-statistics")) +
    ylab(paste(other_rbp, "t-statistics")) +
    theme(axis.line = element_line(colour = "black"),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          panel.grid.major = element_blank(),
          plot.title = element_text(hjust = 0.5),
          text = element_text(size = 20, family = "Arial")) +
    ggtitle(paste("Correlation between", rbp, "and", other_rbp)) +
    ggpubr::stat_cor(method = "spearman", cor.coef.name = "rho", size = 7)
  
  return(p)
}

```

##### GSEA

```{r}
correl_scatter_gsea <- function(gsea_results, rbp, other_rbp) {
  #----------------------------
  # Step 1: Input checks
  #----------------------------
  if (!(rbp %in% names(gsea_results))) stop(paste0("'", rbp, "' not found in gsea_results"))
  if (!(other_rbp %in% names(gsea_results))) stop(paste0("'", other_rbp, "' not found in gsea_results"))
  
  ref_df <- gsea_results[[rbp]]
  other_df <- gsea_results[[other_rbp]]
  
  stopifnot(all(c("pathway", "NES") %in% colnames(ref_df)))
  stopifnot(all(c("pathway", "NES") %in% colnames(other_df)))
  
  #----------------------------
  # Step 2: Merge data
  #----------------------------
  merged <- merge(ref_df, other_df, by = "pathway", suffixes = c(paste0("_", rbp), paste0("_", other_rbp)))
  
  #----------------------------
  # Step 3: Scatter plot
  #----------------------------
  p <- ggplot(merged, aes_string(x = paste0("NES_", rbp), y = paste0("NES_", other_rbp))) +
    geom_point(fill = "#DDDDDD", alpha = 0.3, size = 5, shape = 21, colour = "black") +
    theme_bw() +
    xlab(paste(rbp, "NES")) +
    ylab(paste(other_rbp, "NES")) +
    ggtitle(paste("GSEA correlation between", rbp, "and", other_rbp)) +
    theme(
      axis.line = element_line(colour = "black"),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      panel.background = element_blank(),
      panel.grid.major = element_blank(),
      plot.title = element_text(hjust = 0.5),
      text = element_text(size = 20, family = "Arial MS")
    ) +
    ggpubr::stat_cor(method = "spearman", cor.coef.name = "rho", size = 7)
  
  return(p)
}

```


## B.4.1 Both Cells

#### Expression

```{r}
saveRDS(CharmObj_rbp, "../data/Charm.object.RDS")
Charm.object <- readRDS("../data/Charm.object.RDS")

get_rbp_tvals <- function(Charmobj, rbp) {
  # Suppose `rbp` is the name or index of your RBP
  rbp_data <- Charmobj[[rbp]]$DEGenes  # extract the data.frame for that RBP
  
  # Create new data.frame
  Charmobj$rbp <- data.frame(
    Gene = rownames(rbp_data),
    t = rbp_data[["t"]]   # replace "t" with the column you want
  )
}

rbp_results <- list()
for (rbp in names(Charm.object)) {
  rbp_results[[rbp]] <- get_rbp_tvals(Charm.object, rbp)
}

saveRDS(rbp_results, "../data/RBPs.t_All.RDS")
```

#### GSEA

```{r}
run_gsea_from_tvals <- function(charmobj, rbp) {
# Extract the GSEA data for the specific RBP
gsea_data <- charmobj[[rbp]]$GSEA

# Create a new data.frame with the columns you want
charmobj$rbp <- data.frame(
  pathway = gsea_data[["pathway"]],
  NES = gsea_data[["NES"]]
)
}

gsea_results <- list()
for (rbp in names(rbp_results)) {
  gsea_results[[rbp]] <- run_gsea_from_tvals(Charm.object, rbp)
}

saveRDS(gsea_results, "../data/RBPs.gsea_All.RDS")
```

#### Results

```{r}
result <- exp_correl(rbp_results, "RBFOX2", correl_num = 10)

head(result$top_table)      # table of top correlations
result$heatmap              # ggplot heatmap

result <- gsea_correl(gsea_results, "RBFOX2", correl_num = 10)

head(result$top_table)      # table of top correlations
result$heatmap              # ggplot heatmap

correl_exp_rbp(rbp_results, "RBFOX2", "TIA1")
correl_scatter_gsea(gsea_results, "RBFOX2", "TIA1")
```
## B.4.2 K562

#### Expression

```{r}
Charm.object.K562 <- readRDS("../data/Charm.object_K562.RDS")

rbp_results <- list()
for (rbp in names(Charm.object.K562)) {
  rbp_results[[rbp]] <- get_rbp_tvals(Charm.object.K562, rbp)
}

saveRDS(rbp_results, "../data/RBPs.t_K562.RDS")
```

#### GSEA

```{r}

gsea_results <- list()
for (rbp in names(rbp_results)) {
  gsea_results[[rbp]] <- run_gsea_from_tvals(Charm.object.K562, rbp)
}

saveRDS(gsea_results, "../data/RBPs.gsea_K562.RDS")
```

#### Results

```{r}
result <- exp_correl(rbp_results, "RBFOX2", correl_num = 10)

head(result$top_table)      # table of top correlations
result$heatmap              # ggplot heatmap

result <- gsea_correl(gsea_results, "RBFOX2", correl_num = 10)

head(result$top_table)      # table of top correlations
result$heatmap              # ggplot heatmap

```

## B.4.3 HEPG2

#### Expression

```{r}
Charm.object.HEPG2 <- readRDS("../data/Charm.object_HEPG2.RDS")

rbp_results <- list()
for (rbp in names(Charm.object.HEPG2)) {
  rbp_results[[rbp]] <- get_rbp_tvals(Charm.object.HEPG2, rbp)
}

saveRDS(rbp_results, "../data/RBPs.t_HEPG2.RDS")
```

#### GSEA

```{r}

gsea_results <- list()
for (rbp in names(rbp_results)) {
  gsea_results[[rbp]] <- run_gsea_from_tvals(Charm.object.HEPG2, rbp)
}

saveRDS(gsea_results, "../data/RBPs.gsea_HEPG2.RDS")
```

#### Results

```{r}
result <- exp_correl(rbp_results, "RBFOX2", correl_num = 10)

head(result$top_table)      # table of top correlations
result$heatmap              # ggplot heatmap

result <- gsea_correl(gsea_results, "RBFOX2", correl_num = 10)

head(result$top_table)      # table of top correlations
result$heatmap              # ggplot heatmap

```

## C. Gene Centered Expression

```{r}
available.genes <- unique(unlist(lapply(as.character(names(Charm.object_HEPG2)), function(rbp) {
  obj <- Charm.object_HEPG2[[rbp]]
  
  if (is.null(obj)) {
    warning(paste("No entry for", rbp))
    return(NULL)
  }
  
  df <- obj[["DEGenes"]]
  
  if (is.null(df)) {
    warning(paste("No DEGenes for", rbp))
    return(NULL)
  }
  
  rownames(df)
})))

saveRDS(available.genes, "~/Projects/CHARM/data/AvailableGenes_HEPG2.RDS")

plot_gene_logFC_heatmap <- function(CharmObj, gene) {
  
  # Extract LogFC for the gene across all RBPs safely
  logfc_data <- lapply(names(CharmObj), function(rbp) {
    df <- CharmObj[[rbp]]$DEGenes
    
    # Check that DEGenes exists, has "LogFC", and contains the gene
    if (!is.null(df) && "logFC" %in% colnames(df) && gene %in% rownames(df)) {
      data.frame(RBP = rbp, logFC = df[gene, "logFC"])
    } else {
      # Return NA if not found
      data.frame(RBP = rbp, logFC = NA_real_)
    }
  }) %>%
    bind_rows() %>%
    drop_na(logFC)
  
  # Check that we found the gene somewhere
  if (nrow(logfc_data) == 0) {
    stop(paste("Gene", gene, "not found in any RBP DEGenes tables."))
  }
  
  # Select top 10 and bottom 10
  top10 <- logfc_data %>% arrange(desc(logFC)) %>% slice_head(n = 10)
  bottom10 <- logfc_data %>% arrange(logFC) %>% slice_head(n = 10)
  selected <- bind_rows(top10, bottom10)
  
  # Order RBPs by LogFC for visualization
  selected$RBP <- factor(selected$RBP, levels = selected$RBP[order(selected$logFC)])
  
  # Create the heatmap
ggplot(selected, aes(x = gene, y = RBP, fill = logFC)) +
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%.2f", logFC)), color = "white", size = 5) +
  scale_fill_gradient2(low = "black", mid = "white", high = "#601700", midpoint = 0) +
  labs(
    title = bquote("Top/bottom RBPs by LogFC for " * italic(.(gene))),
    x = "", y = "RBP"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(face = "italic"),
    axis.ticks.x = element_blank()
  )
}

plot_gene_logFC_heatmap(Charm.object, "TP53")
```

## D. Gene Set Centered Expression

```{r}

plot_hallmark_nes_heatmap <- function(CharmObj, geneset) {

  # Extract NES for the geneset across all RBPs safely
  NES_data <- lapply(names(CharmObj), function(rbp) {
    df <- CharmObj[[rbp]]$GSEA

    # Validate structure
    if (!is.null(df) && "NES" %in% colnames(df) && "pathway" %in% colnames(df)) {
      # find rows matching the geneset
      hits <- which(df$pathway == geneset)

      if (length(hits) == 1) {
        data.frame(RBP = rbp, NES = as.numeric(df$NES[hits]), stringsAsFactors = FALSE)
      } else if (length(hits) > 1) {
        # If multiple entries for the same pathway, take the first (or change strategy)
        data.frame(RBP = rbp, NES = as.numeric(df$NES[hits[1]]), stringsAsFactors = FALSE)
      } else {
        data.frame(RBP = rbp, NES = NA_real_, stringsAsFactors = FALSE)
      }
    } else {
      data.frame(RBP = rbp, NES = NA_real_, stringsAsFactors = FALSE)
    }
  }) %>%
    bind_rows() %>%
    drop_na(NES)

  # Check that we found the geneset somewhere
  if (nrow(NES_data) == 0) {
    stop(paste0("Geneset '", geneset, "' not found in any RBP GSEA tables."))
  }

  # Select top 10 and bottom 10
  top10 <- NES_data %>% arrange(desc(NES)) %>% slice_head(n = 10)
  bottom10 <- NES_data %>% arrange(NES) %>% slice_head(n = 10)
  selected <- bind_rows(top10, bottom10)

  # Create a column to use as x-axis (single column heatmap)
  selected$Geneset <- geneset

  # Order RBPs by NES for visualization (from low -> high)
  selected$RBP <- factor(selected$RBP, levels = selected$RBP[order(selected$NES)])

  # Build and return the plot
  p <- ggplot(selected, aes(x = Geneset, y = RBP, fill = NES)) +
    geom_tile(color = "white") +
    geom_text(aes(label = sprintf("%.2f", NES)), color = "white", size = 5) +
    scale_fill_gradient2(low = "black", mid = "white", high = "#601700", midpoint = 0) +
    labs(
      title = paste0("Top/bottom RBPs by NES for ", geneset),
      x = "", y = "RBP"
    ) +
    theme_minimal(base_size = 14) +
    theme(
      axis.ticks.x = element_blank(),
      axis.text.x = element_text(face = "italic")  # italic x-axis label (the geneset)
    )

  return(p)
}
plot_hallmark_nes_heatmap(Charm.object, "HYPOXIA")
```
